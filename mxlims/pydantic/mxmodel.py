# generated by datamodel-codegen:
#   filename:  MxlimsMessage.json
#   timestamp: 2025-03-20T13:04:08+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union
from uuid import UUID

from pydantic import (
    AnyUrl,
    BaseModel,
    Field,
    PositiveFloat,
    PositiveInt,
    RootModel,
    confloat,
    conint,
    constr,
)


class NamespacedExtension(BaseModel):
    """
    JSON schema for extending MxlimsData. To be subclassed
    """

    namespace: str = Field(
        ...,
        description="Namespace string defining 'owner' of the namespace, e.g. 'ESRF, 'GPhL",
        title="Namespace",
    )


class JobStatus(Enum):
    """
    Job status enumeration
    """

    template = "Template"
    ready = "Ready"
    running = "Running"
    completed = "Completed"
    failed = "Failed"
    aborted = "Aborted"


class UnitCell(BaseModel):
    """
    Crystallographic unit cell,

    matches mmCIF items cell.length_{a,b,c} and cell.angle_{alpha,beta,gamma} in category
    cell (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/cell.html)
    """

    a: confloat(ge=0.0) = Field(..., description="A axis length (A)", title="A")
    b: confloat(ge=0.0) = Field(..., description="B axis length (A)", title="B")
    c: confloat(ge=0.0) = Field(..., description="C axis length (A)", title="C")
    alpha: confloat(ge=0.0) = Field(
        ..., description="alpha angle (degree)", title="Alpha"
    )
    beta: confloat(ge=0.0) = Field(..., description="beta angle (degree)", title="Beta")
    gamma: confloat(ge=0.0) = Field(
        ..., description="gamma angle (degree)", title="Gamma"
    )


class SpacegroupName(Enum):
    """
    Space group names for all space groups, including synonyms and non-standard settings
    """

    p1 = "P1"
    p_1 = "P 1"
    p_1_1 = "P-1"
    p__1 = "P -1"
    p2 = "P2"
    p_1_2_1 = "P 1 2 1"
    p121 = "P121"
    p_2 = "P 2"
    p21 = "P21"
    p_1_21_1 = "P 1 21 1"
    p1211 = "P1211"
    p_21 = "P 21"
    c2 = "C2"
    c_1_2_1 = "C 1 2 1"
    c121 = "C121"
    c_2 = "C 2"
    pm = "Pm"
    p_1_m_1 = "P 1 m 1"
    p1m1 = "P1m1"
    p_m = "P m"
    pc = "Pc"
    p_1_c_1 = "P 1 c 1"
    p1c1 = "P1c1"
    p_c = "P c"
    cm = "Cm"
    c_1_m_1 = "C 1 m 1"
    c1m1 = "C1m1"
    c_m = "C m"
    cc = "Cc"
    c_1_c_1 = "C 1 c 1"
    c1c1 = "C1c1"
    c_c = "C c"
    p2_m = "P2/m"
    p_1_2_m_1 = "P 1 2/m 1"
    p12_m1 = "P12/m1"
    p_2_m = "P 2/m"
    p21_m = "P21/m"
    p_1_21_m_1 = "P 1 21/m 1"
    p121_m1 = "P121/m1"
    p_21_m = "P 21/m"
    c2_m = "C2/m"
    c_1_2_m_1 = "C 1 2/m 1"
    c12_m1 = "C12/m1"
    c_2_m = "C 2/m"
    p2_c = "P2/c"
    p_1_2_c_1 = "P 1 2/c 1"
    p12_c1 = "P12/c1"
    p_2_c = "P 2/c"
    p21_c = "P21/c"
    p_1_21_c_1 = "P 1 21/c 1"
    p121_c1 = "P121/c1"
    p_21_c = "P 21/c"
    c2_c = "C2/c"
    c_1_2_c_1 = "C 1 2/c 1"
    c12_c1 = "C12/c1"
    c_2_c = "C 2/c"
    p222 = "P222"
    p_2_2_2 = "P 2 2 2"
    p2221 = "P2221"
    p_2_2_21 = "P 2 2 21"
    p2212 = "P2212"
    p_2_21_2 = "P 2 21 2"
    p2122 = "P2122"
    p_21_2_2 = "P 21 2 2"
    p21212 = "P21212"
    p_21_21_2 = "P 21 21 2"
    p21221 = "P21221"
    p_21_2_21 = "P 21 2 21"
    p22121 = "P22121"
    p_2_21_21 = "P 2 21 21"
    p212121 = "P212121"
    p_21_21_21 = "P 21 21 21"
    c2221 = "C2221"
    c_2_2_21 = "C 2 2 21"
    c222 = "C222"
    c_2_2_2 = "C 2 2 2"
    f222 = "F222"
    f_2_2_2 = "F 2 2 2"
    i222 = "I222"
    i_2_2_2 = "I 2 2 2"
    i212121 = "I212121"
    i_21_21_21 = "I 21 21 21"
    pmm2 = "Pmm2"
    p_m_m_2 = "P m m 2"
    pmc21 = "Pmc21"
    p_m_c_21 = "P m c 21"
    pcc2 = "Pcc2"
    p_c_c_2 = "P c c 2"
    pma2 = "Pma2"
    p_m_a_2 = "P m a 2"
    pca21 = "Pca21"
    p_c_a_21 = "P c a 21"
    pnc2 = "Pnc2"
    p_n_c_2 = "P n c 2"
    pmn21 = "Pmn21"
    p_m_n_21 = "P m n 21"
    pba2 = "Pba2"
    p_b_a_2 = "P b a 2"
    pna21 = "Pna21"
    p_n_a_21 = "P n a 21"
    pnn2 = "Pnn2"
    p_n_n_2 = "P n n 2"
    cmm2 = "Cmm2"
    c_m_m_2 = "C m m 2"
    cmc21 = "Cmc21"
    c_m_c_21 = "C m c 21"
    ccc2 = "Ccc2"
    c_c_c_2 = "C c c 2"
    amm2 = "Amm2"
    a_m_m_2 = "A m m 2"
    abm2 = "Abm2"
    a_b_m_2 = "A b m 2"
    ama2 = "Ama2"
    a_m_a_2 = "A m a 2"
    aba2 = "Aba2"
    a_b_a_2 = "A b a 2"
    fmm2 = "Fmm2"
    f_m_m_2 = "F m m 2"
    fdd2 = "Fdd2"
    f_d_d_2 = "F d d 2"
    imm2 = "Imm2"
    i_m_m_2 = "I m m 2"
    iba2 = "Iba2"
    i_b_a_2 = "I b a 2"
    ima2 = "Ima2"
    i_m_a_2 = "I m a 2"
    pmmm = "Pmmm"
    p_2_m_2_m_2_m = "P 2/m 2/m 2/m"
    p2_m2_m2_m = "P2/m2/m2/m"
    p_m_m_m = "P m m m"
    pnnn = "Pnnn"
    p_2_n_2_n_2_n = "P 2/n 2/n 2/n"
    p2_n2_n2_n = "P2/n2/n2/n"
    p_n_n_n = "P n n n"
    pccm = "Pccm"
    p_2_c_2_c_2_m = "P 2/c 2/c 2/m"
    p2_c2_c2_m = "P2/c2/c2/m"
    p_c_c_m = "P c c m"
    pban = "Pban"
    p_2_b_2_a_2_n = "P 2/b 2/a 2/n"
    p2_b2_a2_n = "P2/b2/a2/n"
    p_b_a_n = "P b a n"
    pmma = "Pmma"
    p_21_m_2_m_2_a = "P 21/m 2/m 2/a"
    p21_m2_m2_a = "P21/m2/m2/a"
    p_m_m_a = "P m m a"
    pnna = "Pnna"
    p_2_n_21_n_2_a = "P 2/n 21/n 2/a"
    p2_n21_n2_a = "P2/n21/n2/a"
    p_n_n_a = "P n n a"
    pmna = "Pmna"
    p_2_m_2_n_21_a = "P 2/m 2/n 21/a"
    p2_m2_n21_a = "P2/m2/n21/a"
    p_m_n_a = "P m n a"
    pcca = "Pcca"
    p_21_c_2_c_2_a = "P 21/c 2/c 2/a"
    p21_c2_c2_a = "P21/c2/c2/a"
    p_c_c_a = "P c c a"
    pbam = "Pbam"
    p_21_b_21_a_2_m = "P 21/b 21/a 2/m"
    p21_b21_a2_m = "P21/b21/a2/m"
    p_b_a_m = "P b a m"
    pccn = "Pccn"
    p_21_c_21_c_2_n = "P 21/c 21/c 2/n"
    p21_c21_c2_n = "P21/c21/c2/n"
    p_c_c_n = "P c c n"
    pbcm = "Pbcm"
    p_2_b_21_c_21_m = "P 2/b 21/c 21/m"
    p2_b21_c21_m = "P2/b21/c21/m"
    p_b_c_m = "P b c m"
    pnnm = "Pnnm"
    p_21_n_21_n_2_m = "P 21/n 21/n 2/m"
    p21_n21_n2_m = "P21/n21/n2/m"
    p_n_n_m = "P n n m"
    pmmn = "Pmmn"
    p_21_m_21_m_2_n = "P 21/m 21/m 2/n"
    p21_m21_m2_n = "P21/m21/m2/n"
    p_m_m_n = "P m m n"
    pbcn = "Pbcn"
    p_21_b_2_c_21_n = "P 21/b 2/c 21/n"
    p21_b2_c21_n = "P21/b2/c21/n"
    p_b_c_n = "P b c n"
    pbca = "Pbca"
    p_21_b_21_c_21_a = "P 21/b 21/c 21/a"
    p21_b21_c21_a = "P21/b21/c21/a"
    p_b_c_a = "P b c a"
    pnma = "Pnma"
    p_21_n_21_m_21_a = "P 21/n 21/m 21/a"
    p21_n21_m21_a = "P21/n21/m21/a"
    p_n_m_a = "P n m a"
    cmcm = "Cmcm"
    c_2_m_2_c_21_m = "C 2/m 2/c 21/m"
    c2_m2_c21_m = "C2/m2/c21/m"
    c_m_c_m = "C m c m"
    cmca = "Cmca"
    c_2_m_2_c_21_a = "C 2/m 2/c 21/a"
    c2_m2_c21_a = "C2/m2/c21/a"
    c_m_c_a = "C m c a"
    cmmm = "Cmmm"
    c_2_m_2_m_2_m = "C 2/m 2/m 2/m"
    c2_m2_m2_m = "C2/m2/m2/m"
    c_m_m_m = "C m m m"
    cccm = "Cccm"
    c_2_c_2_c_2_m = "C 2/c 2/c 2/m"
    c2_c2_c2_m = "C2/c2/c2/m"
    c_c_c_m = "C c c m"
    cmma = "Cmma"
    c_2_m_2_m_2_a = "C 2/m 2/m 2/a"
    c2_m2_m2_a = "C2/m2/m2/a"
    c_m_m_a = "C m m a"
    ccca = "Ccca"
    c_2_c_2_c_2_a = "C 2/c 2/c 2/a"
    c2_c2_c2_a = "C2/c2/c2/a"
    c_c_c_a = "C c c a"
    fmmm = "Fmmm"
    f_2_m_2_m_2_m = "F 2/m 2/m 2/m"
    f2_m2_m2_m = "F2/m2/m2/m"
    f_m_m_m = "F m m m"
    fddd = "Fddd"
    f_2_d_2_d_2_d = "F 2/d 2/d 2/d"
    f2_d2_d2_d = "F2/d2/d2/d"
    f_d_d_d = "F d d d"
    immm = "Immm"
    i_2_m_2_m_2_m = "I 2/m 2/m 2/m"
    i2_m2_m2_m = "I2/m2/m2/m"
    i_m_m_m = "I m m m"
    ibam = "Ibam"
    i_2_b_2_a_2_m = "I 2/b 2/a 2/m"
    i2_b2_a2_m = "I2/b2/a2/m"
    i_b_a_m = "I b a m"
    ibca = "Ibca"
    i_21_b_21_c_21_a = "I 21/b 21/c 21/a"
    i21_b21_c21_a = "I21/b21/c21/a"
    i_b_c_a = "I b c a"
    imma = "Imma"
    i_21_m_21_m_21_a = "I 21/m 21/m 21/a"
    i21_m21_m21_a = "I21/m21/m21/a"
    i_m_m_a = "I m m a"
    p4 = "P4"
    p_4 = "P 4"
    p41 = "P41"
    p_41 = "P 41"
    p42 = "P42"
    p_42 = "P 42"
    p43 = "P43"
    p_43 = "P 43"
    i4 = "I4"
    i_4 = "I 4"
    i41 = "I41"
    i_41 = "I 41"
    p_4_1 = "P-4"
    p__4 = "P -4"
    i_4_1 = "I-4"
    i__4 = "I -4"
    p4_m = "P4/m"
    p_4_m = "P 4/m"
    p42_m = "P42/m"
    p_42_m = "P 42/m"
    p4_n = "P4/n"
    p_4_n = "P 4/n"
    p42_n = "P42/n"
    p_42_n = "P 42/n"
    i4_m = "I4/m"
    i_4_m = "I 4/m"
    i41_a = "I41/a"
    i_41_a = "I 41/a"
    p422 = "P422"
    p_4_2_2 = "P 4 2 2"
    p4212 = "P4212"
    p_4_21_2 = "P 4 21 2"
    p4122 = "P4122"
    p_41_2_2 = "P 41 2 2"
    p41212 = "P41212"
    p_41_21_2 = "P 41 21 2"
    p4222 = "P4222"
    p_42_2_2 = "P 42 2 2"
    p42212 = "P42212"
    p_42_21_2 = "P 42 21 2"
    p4322 = "P4322"
    p_43_2_2 = "P 43 2 2"
    p43212 = "P43212"
    p_43_21_2 = "P 43 21 2"
    i422 = "I422"
    i_4_2_2 = "I 4 2 2"
    i4122 = "I4122"
    i_41_2_2 = "I 41 2 2"
    p4mm = "P4mm"
    p_4_m_m = "P 4 m m"
    p4bm = "P4bm"
    p_4_b_m = "P 4 b m"
    p42cm = "P42cm"
    p_42_c_m = "P 42 c m"
    p42nm = "P42nm"
    p_42_n_m = "P 42 n m"
    p4cc = "P4cc"
    p_4_c_c = "P 4 c c"
    p4nc = "P4nc"
    p_4_n_c = "P 4 n c"
    p42mc = "P42mc"
    p_42_m_c = "P 42 m c"
    p42bc = "P42bc"
    p_42_b_c = "P 42 b c"
    i4mm = "I4mm"
    i_4_m_m = "I 4 m m"
    i4cm = "I4cm"
    i_4_c_m = "I 4 c m"
    i41md = "I41md"
    i_41_m_d = "I 41 m d"
    i41cd = "I41cd"
    i_41_c_d = "I 41 c d"
    p_42m = "P-42m"
    p__4_2_m = "P -4 2 m"
    p_42c = "P-42c"
    p__4_2_c = "P -4 2 c"
    p_421m = "P-421m"
    p__4_21_m = "P -4 21 m"
    p_421c = "P-421c"
    p__4_21_c = "P -4 21 c"
    p_4m2 = "P-4m2"
    p__4_m_2 = "P -4 m 2"
    p_4c2 = "P-4c2"
    p__4_c_2 = "P -4 c 2"
    p_4b2 = "P-4b2"
    p__4_b_2 = "P -4 b 2"
    p_4n2 = "P-4n2"
    p__4_n_2 = "P -4 n 2"
    i_4m2 = "I-4m2"
    i__4_m_2 = "I -4 m 2"
    i_4c2 = "I-4c2"
    i__4_c_2 = "I -4 c 2"
    i_42m = "I-42m"
    i__4_2_m = "I -4 2 m"
    i_42d = "I-42d"
    i__4_2_d = "I -4 2 d"
    p4_mmm = "P4/mmm"
    p_4_m_2_m_2_m = "P 4/m 2/m 2/m"
    p4_m2_m2_m = "P4/m2/m2/m"
    p4_m_m_m = "P4/m m m"
    p4_mcc = "P4/mcc"
    p_4_m_2_c_2_c = "P 4/m 2/c 2/c"
    p4_m2_c2_c = "P4/m2/c2/c"
    p4_m_c_c = "P4/m c c"
    p4_nbm = "P4/nbm"
    p_4_n_2_b_2_m = "P 4/n 2/b 2/m"
    p4_n2_b2_m = "P4/n2/b2/m"
    p4_n_b_m = "P4/n b m"
    p4_nnc = "P4/nnc"
    p_4_n_2_n_2_c = "P 4/n 2/n 2/c"
    p4_n2_n2_c = "P4/n2/n2/c"
    p4_n_n_c = "P4/n n c"
    p4_mbm = "P4/mbm"
    p_4_m_21_b_2_m = "P 4/m 21/b 2/m"
    p4_m21_b2_m = "P4/m21/b2/m"
    p4_m_b_m = "P4/m b m"
    p4_mnc = "P4/mnc"
    p_4_m_21_n_2_c = "P 4/m 21/n 2/c"
    p4_m21_n2_c = "P4/m21/n2/c"
    p4_m_n_c = "P4/m n c"
    p4_nmm = "P4/nmm"
    p_4_n_21_m_2_m = "P 4/n 21/m 2/m"
    p4_n21_m2_m = "P4/n21/m2/m"
    p4_n_m_m = "P4/n m m"
    p4_ncc = "P4/ncc"
    p_4_n_2_c_2_c = "P 4/n 2/c 2/c"
    p4_n2_c2_c = "P4/n2/c2/c"
    p4_n_c_c = "P4/n c c"
    p42_mmc = "P42/mmc"
    p_42_m_2_m_2_c = "P 42/m 2/m 2/c"
    p42_m2_m2_c = "P42/m2/m2/c"
    p42_m_m_c = "P42/m m c"
    p42_mcm = "P42/mcm"
    p_42_m_2_c_2_m = "P 42/m 2/c 2/m"
    p42_m2_c2_m = "P42/m2/c2/m"
    p42_m_c_m = "P42/m c m"
    p42_nbc = "P42/nbc"
    p_42_n_2_b_2_c = "P 42/n 2/b 2/c"
    p42_n2_b2_c = "P42/n2/b2/c"
    p42_n_b_c = "P42/n b c"
    p42_nnm = "P42/nnm"
    p_42_n_2_n_2_m = "P 42/n 2/n 2/m"
    p42_n2_n2_m = "P42/n2/n2/m"
    p42_n_n_m = "P42/n n m"
    p42_mbc = "P42/mbc"
    p_42_m_21_b_2_c = "P 42/m 21/b 2/c"
    p42_m21_b2_c = "P42/m21/b2/c"
    p42_m_b_c = "P42/m b c"
    p42_mnm = "P42/mnm"
    p_42_m_21_n_2_m = "P 42/m 21/n 2/m"
    p42_m21_n2_m = "P42/m21/n2/m"
    p42_m_n_m = "P42/m n m"
    p42_nmc = "P42/nmc"
    p_42_n_21_m_2_c = "P 42/n 21/m 2/c"
    p42_n21_m2_c = "P42/n21/m2/c"
    p42_n_m_c = "P42/n m c"
    p42_ncm = "P42/ncm"
    p_42_n_21_c_2_m = "P 42/n 21/c 2/m"
    p42_n21_c2_m = "P42/n21/c2/m"
    p42_n_c_m = "P42/n c m"
    i4_mmm = "I4/mmm"
    i_4_m_2_m_2_m = "I 4/m 2/m 2/m"
    i4_m2_m2_m = "I4/m2/m2/m"
    i4_m_m_m = "I4/m m m"
    i4_mcm = "I4/mcm"
    i_4_m_2_c_2_m = "I 4/m 2/c 2/m"
    i4_m2_c2_m = "I4/m2/c2/m"
    i4_m_c_m = "I4/m c m"
    i41_amd = "I41/amd"
    i_41_a_2_m_2_d = "I 41/a 2/m 2/d"
    i41_a2_m2_d = "I41/a2/m2/d"
    i41_a_m_d = "I41/a m d"
    i41_acd = "I41/acd"
    i_41_a_2_c_2_d = "I 41/a 2/c 2/d"
    i41_a2_c2_d = "I41/a2/c2/d"
    i41_a_c_d = "I41/a c d"
    p3 = "P3"
    p_3 = "P 3"
    p31 = "P31"
    p_31 = "P 31"
    p32 = "P32"
    p_32 = "P 32"
    r3 = "R3"
    h_3 = "H 3"
    h3 = "H3"
    r_3 = "R 3"
    p_3_1 = "P-3"
    p__3 = "P -3"
    r_3_1 = "R-3"
    h__3 = "H -3"
    h_3_1 = "H-3"
    r__3 = "R -3"
    p312 = "P312"
    p_3_1_2 = "P 3 1 2"
    p321 = "P321"
    p_3_2_1 = "P 3 2 1"
    p3112 = "P3112"
    p_31_1_2 = "P 31 1 2"
    p3121 = "P3121"
    p_31_2_1 = "P 31 2 1"
    p3212 = "P3212"
    p_32_1_2 = "P 32 1 2"
    p3221 = "P3221"
    p_32_2_1 = "P 32 2 1"
    r32 = "R32"
    h_3_2 = "H 3 2"
    h32 = "H32"
    r_3_2 = "R 3 2"
    p3m1 = "P3m1"
    p_3_m_1 = "P 3 m 1"
    p31m = "P31m"
    p_3_1_m = "P 3 1 m"
    p3c1 = "P3c1"
    p_3_c_1 = "P 3 c 1"
    p31c = "P31c"
    p_3_1_c = "P 3 1 c"
    r3m = "R3m"
    h_3_m = "H 3 m"
    h3m = "H3m"
    r_3_m = "R 3 m"
    r3c = "R3c"
    h_3_c = "H 3 c"
    h3c = "H3c"
    r_3_c = "R 3 c"
    p_31m = "P-31m"
    p__3_1_2_m = "P -3 1 2/m"
    p_312_m = "P-312/m"
    p__3_1_m = "P -3 1 m"
    p_31c = "P-31c"
    p__3_1_2_c = "P -3 1 2/c"
    p_312_c = "P-312/c"
    p__3_1_c = "P -3 1 c"
    p_3m1 = "P-3m1"
    p__3_2_m_1 = "P -3 2/m 1"
    p_32_m1 = "P-32/m1"
    p__3_m_1 = "P -3 m 1"
    p_3c1 = "P-3c1"
    p__3_2_c_1 = "P -3 2/c 1"
    p_32_c1 = "P-32/c1"
    p__3_c_1 = "P -3 c 1"
    r_3m = "R-3m"
    h_3m = "H-3m"
    h__3_2_m = "H -3 2/m"
    h_32_m = "H-32/m"
    h__3_m = "H -3 m"
    r__3_2_m = "R -3 2/m"
    r_32_m = "R-32/m"
    r__3_m = "R -3 m"
    r_3c = "R-3c"
    h_3c = "H-3c"
    h__3_2_c = "H -3 2/c"
    h_32_c = "H-32/c"
    h__3_c = "H -3 c"
    r__3_2_c = "R -3 2/c"
    r_32_c = "R-32/c"
    r__3_c = "R -3 c"
    p6 = "P6"
    p_6 = "P 6"
    p61 = "P61"
    p_61 = "P 61"
    p65 = "P65"
    p_65 = "P 65"
    p62 = "P62"
    p_62 = "P 62"
    p64 = "P64"
    p_64 = "P 64"
    p63 = "P63"
    p_63 = "P 63"
    p_6_1 = "P-6"
    p__6 = "P -6"
    p6_m = "P6/m"
    p_6_m = "P 6/m"
    p63_m = "P63/m"
    p_63_m = "P 63/m"
    p622 = "P622"
    p_6_2_2 = "P 6 2 2"
    p6122 = "P6122"
    p_61_2_2 = "P 61 2 2"
    p6522 = "P6522"
    p_65_2_2 = "P 65 2 2"
    p6222 = "P6222"
    p_62_2_2 = "P 62 2 2"
    p6422 = "P6422"
    p_64_2_2 = "P 64 2 2"
    p6322 = "P6322"
    p_63_2_2 = "P 63 2 2"
    p6mm = "P6mm"
    p_6_m_m = "P 6 m m"
    p6cc = "P6cc"
    p_6_c_c = "P 6 c c"
    p63cm = "P63cm"
    p_63_c_m = "P 63 c m"
    p63mc = "P63mc"
    p_63_m_c = "P 63 m c"
    p_6m2 = "P-6m2"
    p__6_m_2 = "P -6 m 2"
    p_6c2 = "P-6c2"
    p__6_c_2 = "P -6 c 2"
    p_62m = "P-62m"
    p__6_2_m = "P -6 2 m"
    p_62c = "P-62c"
    p__6_2_c = "P -6 2 c"
    p6_mmm = "P6/mmm"
    p_6_m_2_m_2_m = "P 6/m 2/m 2/m"
    p6_m2_m2_m = "P6/m2/m2/m"
    p_6_m_m_m = "P 6/m m m"
    p6_mcc = "P6/mcc"
    p_6_m_2_c_2_c = "P 6/m 2/c 2/c"
    p6_m2_c2_c = "P6/m2/c2/c"
    p_6_m_c_c = "P 6/m c c"
    p63_mcm = "P63/mcm"
    p_63_m_2_c_2_m = "P 63/m 2/c 2/m"
    p63_m2_c2_m = "P63/m2/c2/m"
    p_63_m_c_m = "P 63/m c m"
    p63_mmc = "P63/mmc"
    p_63_m_2_m_2_c = "P 63/m 2/m 2/c"
    p63_m2_m2_c = "P63/m2/m2/c"
    p_63_m_m_c = "P 63/m m c"
    p23 = "P23"
    p_2_3 = "P 2 3"
    f23 = "F23"
    f_2_3 = "F 2 3"
    i23 = "I23"
    i_2_3 = "I 2 3"
    p213 = "P213"
    p_21_3 = "P 21 3"
    i213 = "I213"
    i_21_3 = "I 21 3"
    pm_3 = "Pm-3"
    p_2_m__3 = "P 2/m -3"
    p2_m_3 = "P2/m-3"
    p_m__3 = "P m -3"
    pn_3 = "Pn-3"
    p_2_n__3 = "P 2/n -3"
    p2_n_3 = "P2/n-3"
    p_n__3 = "P n -3"
    fm_3 = "Fm-3"
    f_2_m__3 = "F 2/m -3"
    f2_m_3 = "F2/m-3"
    f_m__3 = "F m -3"
    fd_3 = "Fd-3"
    f_2_d__3 = "F 2/d -3"
    f2_d_3 = "F2/d-3"
    f_d__3 = "F d -3"
    im_3 = "Im-3"
    i_2_m__3 = "I 2/m -3"
    i2_m_3 = "I2/m-3"
    i_m__3 = "I m -3"
    pa_3 = "Pa-3"
    p_21_a__3 = "P 21/a -3"
    p21_a_3 = "P21/a-3"
    p_a__3 = "P a -3"
    ia_3 = "Ia-3"
    i_21_a__3 = "I 21/a -3"
    i21_a_3 = "I21/a-3"
    i_a__3 = "I a -3"
    p432 = "P432"
    p_4_3_2 = "P 4 3 2"
    p4232 = "P4232"
    p_42_3_2 = "P 42 3 2"
    f432 = "F432"
    f_4_3_2 = "F 4 3 2"
    f4132 = "F4132"
    f_41_3_2 = "F 41 3 2"
    i432 = "I432"
    i_4_3_2 = "I 4 3 2"
    p4332 = "P4332"
    p_43_3_2 = "P 43 3 2"
    p4132 = "P4132"
    p_41_3_2 = "P 41 3 2"
    i4132 = "I4132"
    i_41_3_2 = "I 41 3 2"
    p_43m = "P-43m"
    p__4_3_m = "P -4 3 m"
    f_43m = "F-43m"
    f__4_3_m = "F -4 3 m"
    i_43m = "I-43m"
    i__4_3_m = "I -4 3 m"
    p_43n = "P-43n"
    p__4_3_n = "P -4 3 n"
    f_43c = "F-43c"
    f__4_3_c = "F -4 3 c"
    i_43d = "I-43d"
    i__4_3_d = "I -4 3 d"
    pm_3m = "Pm-3m"
    p_4_m__3_2_m = "P 4/m -3 2/m"
    p4_m_32_m = "P4/m-32/m"
    p_m__3_m = "P m -3 m"
    pn_3n = "Pn-3n"
    p_4_n__3_2_n = "P 4/n -3 2/n"
    p4_n_32_n = "P4/n-32/n"
    p_n__3_n = "P n -3 n"
    pm_3n = "Pm-3n"
    p_42_m__3_2_n = "P 42/m -3 2/n"
    p42_m_32_n = "P42/m-32/n"
    p_m__3_n = "P m -3 n"
    pn_3m = "Pn-3m"
    p_42_n__3_2_m = "P 42/n -3 2/m"
    p42_n_32_m = "P42/n-32/m"
    p_n__3_m = "P n -3 m"
    fm_3m = "Fm-3m"
    f_4_m__3_2_m = "F 4/m -3 2/m"
    f4_m_32_m = "F4/m-32/m"
    f_m__3_m = "F m -3 m"
    fm_3c = "Fm-3c"
    f_4_m__3_2_c = "F 4/m -3 2/c"
    f4_m_32_c = "F4/m-32/c"
    f_m__3_c = "F m -3 c"
    fd_3m = "Fd-3m"
    f_41_d__3_2_m = "F 41/d -3 2/m"
    f41_d_32_m = "F41/d-32/m"
    f_d__3_m = "F d -3 m"
    fd_3c = "Fd-3c"
    f_41_d__3_2_c = "F 41/d -3 2/c"
    f41_d_32_c = "F41/d-32/c"
    f_d__3_c = "F d -3 c"
    im_3m = "Im-3m"
    i_4_m__3_2_m = "I 4/m -3 2/m"
    i4_m_32_m = "I4/m-32/m"
    i_m__3_m = "I m -3 m"
    ia_3d = "Ia-3d"
    i_41_a__3_2_d = "I 41/a -3 2/d"
    i41_a_32_d = "I41/a-32/d"
    i_a__3_d = "I a -3 d"


class Tensor(BaseModel):
    """
    Tensor
    """

    eigenvalues: List = Field(
        ...,
        description="Eigenvalues of tensor",
        max_length=3,
        min_length=3,
        title="Eigenvalues",
    )
    eigenvectors: List[List] = Field(
        ...,
        description="Eigenvectors (unit vectors) of tensor, in same order as eigenvalues",
        title="Eigenvectors",
    )


class QualityFactorType(Enum):
    """
    Name for quality factor type, used in QualityFactor class
    """

    r_merge_ = "R(merge)"
    r_meas_ = "R(meas)"
    r_pim_ = "R(pim)"
    i_sig_i = "I/SigI"
    cc_1_2_ = "CC(1/2)"
    cc_ano_ = "CC(ano)"
    sig_ano = "SigAno"
    completeness = "Completeness"
    completeness_spherical = "CompletenessSpherical"
    completeness_ellipsoidal = "CompletenessEllipsoidal"
    redundancy = "Redundancy"
    completeness_ano = "CompletenessAno"
    completeness_ano_spherical = "CompletenessAnoSpherical"
    completeness_ano_ellipsoidal = "CompletenessAnoEllipsoidal"
    redundancy_ano = "RedundancyAno"


class PdbxSignalType(Enum):
    """
    Observability criterion. Matches mmCIF item reflns.pdbx_signal_type

    https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_signal_type.html)
    """

    local__i_sigma_i_ = "local <I/sigmaI>"
    local_w_cc_half = "local wCC_half"


class ReflectionBinningMode(Enum):
    """
    Reflection binning mode for binning reflection statistics
    """

    equal_volume = "equalVolume"
    equal_number = "equalNumber"
    dstar_equidistant = "dstarEquidistant"
    dstar2_equidistant = "dstar2Equidistant"


class ReflectionFileType(Enum):
    """
    Name for file type, used in ReflectionSet class
    """

    scaled_and_merged_mtz = "scaled and merged MTZ"
    scaled_and_unmerged_mtz = "scaled and unmerged MTZ"
    unmerged_mtz = "unmerged MTZ"
    xds_integrate_hkl__unmerged__https___xds_mr_mpg_de_html_doc_xds_files_html_integrate_hkl_ = "XDS INTEGRATE.HKL; unmerged (https://xds.mr.mpg.de/html_doc/xds_files.html#INTEGRATE.HKL)"
    xds_xds_ascii_hkl__scaled_and_unmerged__https___xds_mr_mpg_de_html_doc_xds_files_html_xds_ascii_hkl_ = "XDS XDS_ASCII.HKL; scaled and unmerged (https://xds.mr.mpg.de/html_doc/xds_files.html#XDS_ASCII.HKL)"


class Scan(BaseModel):
    """
    Subdivision of CollectionSweep.

    The Scan describes a continuously acquired set of images that forms a subset of the
    CollectionSweep of which they form part. The ordinal gives the acquisition order of
    sweeps across an entire multi-sweep experiment; this allows you to describe
    out-of-order acquisition and interleaving.
    """

    scan_position_start: float = Field(
        ...,
        alias="scanPositionStart",
        description="Value of scan axis for the first image, in units matching axis type",
        title="Scan Position Start",
    )
    first_image_number: int = Field(
        ...,
        alias="firstImageNumber",
        description="Image number to use for first image",
        title="First Image Number",
    )
    number_images: conint(ge=0) = Field(
        ...,
        alias="numberImages",
        description="Number of images to acquire as part of the Scan.",
        title="Number Images",
    )
    ordinal: int = Field(
        ...,
        description="Ordinal defining the ordering of all scans within the experiment (not just within the scan)",
        title="Ordinal",
    )


class SampleComponent(BaseModel):
    """
    Component of Sample.
    """

    acronym: Optional[str] = Field(
        None,
        description="Acronym - short synonym of component (e.g. 'lig1'",
        title="Acronym",
    )
    name: Optional[str] = Field(
        None, description="Human readable name of component", title="Name"
    )
    role: Optional[str] = Field(
        None,
        description="Role of component in PreparedSample",
        examples=["solvent", "cryoprotectant", "ligand", "inhibitor", "target"],
        title="Role",
    )
    identifiers: Optional[Dict[str, str]] = Field(
        None,
        description="Dictionary str:str of contextName: identifier. ContextName will typically refer to a LIMS, database, or web site but could also be e.g. 'smiles' or 'sequence'",
        title="Identifiers",
    )


class TrackingDeviceType(Enum):
    """
    Type of tracking device for tracking samples, Dewars, etc.
    """

    light_bug = "LightBug"
    air_tag = "AirTag"
    other = "other"


class Point(BaseModel):
    """
    A point marked on an image or in absolute plate space.
    """

    region_type: Literal["point"] = Field(
        ..., alias="regionType", description="Type of region", title="Region type"
    )
    x: float = Field(..., description="The X co-ordinate of the point.")
    y: float = Field(..., description="The Y co-ordinate of the point.")


class Circle(BaseModel):
    """
    A circle marked on an image or in absolute plate space.
    """

    region_type: Literal["circle"] = Field(
        ..., alias="regionType", description="Type of region", title="Region type"
    )
    center: Point
    radius: PositiveFloat = Field(..., description="The radius of the circle.")


class Line(BaseModel):
    """
    A straight line marked on an image or in absolute plate space.
    """

    region_type: Literal["line"] = Field(
        ..., alias="regionType", description="Type of region", title="Region type"
    )
    points: List[Point] = Field(..., max_length=2, min_length=2)


class Rectangle(BaseModel):
    """
    <A rectangular region marked on an image or in absolute plate space. The box is defined by two points on diagonally opposite corners, with its edges parallel to the X and Y axes. Ensure that the two X values are not equal, and that the two Y values are not equal.
    """

    region_type: Literal["rectangle"] = Field(
        ..., alias="regionType", description="Type of region", title="Region type"
    )
    points: List[Point] = Field(..., max_length=2, min_length=2)


class Polygon(BaseModel):
    """
    <A polygonal region marked on an image or in absolute plate space.The polygon is defined by at least three points, and is assumed to be closed by a line from the last point to the first. The path should not cross itself, including on the closing segment.
    """

    region_type: Literal["polygon"] = Field(
        ..., alias="regionType", description="Type of region", title="Region type"
    )
    points: List[Point] = Field(..., min_length=3)


class ImageMimeType(Enum):
    """
    Mimetype deccribign image format
    """

    image_png = "image/png"
    image_jpeg = "image/jpeg"


class ImageLightType(Enum):
    """
    Type of light used e.g. for capturing an image
    """

    visible = "Visible"
    uv = "UV"
    other = "other"


class ImageRegionUnit(Enum):
    """
    Allowed units for image region images
    """

    mm = "mm"
    micron = "micron"
    pixel = "pixel"


class PlateRegionUnit(Enum):
    """
    Allowed units for plate region images
    """

    mm = "mm"
    micron = "micron"


class PlateType(BaseModel):
    """
    A type of crystallization plate.
    """

    name: Optional[str] = Field(
        None,
        description="The name of the plate type.",
        examples=["Greiner 1-drop square"],
    )
    number_rows: conint(ge=1) = Field(
        ...,
        alias="numberRows",
        description="The number of rows in the plate. For a typical 96-well plate, this will be 8.",
    )
    number_columns: conint(ge=1) = Field(
        ...,
        alias="numberColumns",
        description="The number of columns in the plate. For a typical 96-well plate, this will be 12.",
    )
    number_sub_positions: conint(ge=1) = Field(
        ...,
        alias="numberSubPositions",
        description="The number of sub-wells in the plate. For in-situ plates with no dividers, this should be the actual number of drops dispensed.",
    )
    drop_mapping: str = Field(
        ...,
        alias="dropMapping",
        description="<p>The sender's numbering of the sub-wells. This can be used by the receiver to map the sender's well numbering onto their own.<p><p>It is an error if the sender and receiver disagree on the basic geometry (e.g., three drops across the top with a reservoir underneath). However, they can disagree on the drop order; this property is intended to help overcome such disagreements.</p>",
        examples=["123,RRR", "23,1R"],
    )


class EnumerateTrue(Enum):
    """
    Enumeration containing only `true`, to use for optional single-value property
    """

    boolean_true = True


class Person(BaseModel):
    """
    Person
    """

    name: str = Field(..., description="The person's full name.")
    email_address: Optional[str] = Field(
        None, alias="emailAddress", description="The person's email address."
    )
    phone_number: Optional[str] = Field(
        None, alias="phoneNumber", description="The person's phone number."
    )


class MxlimsData(BaseModel):
    """
    Abstract superclass for Metadata
    """

    mxlims_type: str = Field(
        ...,
        alias="mxlimsType",
        description="The type of MXLIMS data. May be restricted to enum in subclasses",
        title="Mxlims Type",
    )
    namespaced_extensions: Optional[List[NamespacedExtension]] = Field(
        None,
        alias="namespacedExtensions",
        description="List of extensions to metadata, each defined in a NamespacedExtension schema",
        title="Namespaced Extensions",
    )


class CrystalForm1(BaseModel):
    """
    Crystal form, fully or partially specified
    """

    unit_cell: Optional[UnitCell] = Field(
        None, alias="unitCell", description="Unit cell for Crystal form."
    )
    space_group_name: SpacegroupName = Field(
        ...,
        alias="spaceGroupName",
        description="Name of expected space group, for processing. Names may include alternative settings. Matches mmCIF item symmetry.space_group_name_H-M (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_symmetry.space_group_name_H-M.html).",
        title="Space Group Name",
    )


class CrystalForm2(BaseModel):
    """
    Crystal form, fully or partially specified
    """

    unit_cell: UnitCell = Field(
        ..., alias="unitCell", description="Unit cell for Crystal form."
    )
    space_group_name: Optional[SpacegroupName] = Field(
        None,
        alias="spaceGroupName",
        description="Name of expected space group, for processing. Names may include alternative settings. Matches mmCIF item symmetry.space_group_name_H-M (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_symmetry.space_group_name_H-M.html).",
        title="Space Group Name",
    )


class CrystalForm(RootModel[Union[CrystalForm1, CrystalForm2]]):
    root: Union[CrystalForm1, CrystalForm2] = Field(
        ...,
        description="Crystal form, fully or partially specified",
        title="Crystal Form",
    )


class QualityFactor(BaseModel):
    """
    Reflection shell quality factor. Enumerated type with associated value
    . Correspondence with mmCIF items:

      Overall (mmCIF reflns category, https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/reflns.html)

        R(merge)                      reflns.pdbx_Rmerge_I_obs                                 https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_Rmerge_I_obs.html
        R(meas)                       reflns.pdbx_Rrim_I_all                                   https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_Rrim_I_all.html
        R(pim)                        reflns.pdbx_Rpim_I_all                                   https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_Rpim_I_all.html
        I/SigI                        reflns.pdbx_netI_over_sigmaI                             https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_netI_over_sigmaI.html
        CC(1/2)                       reflns.pdbx_CC_half                                      https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_CC_half.html
        CC(ano)                       reflns.pdbx_CC_half_anomalous                            https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_CC_half_anomalous.html
        SigAno                        reflns.pdbx_absDiff_over_sigma_anomalous                 https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_absDiff_over_sigma_anomalous.html
        Completeness                  reflns.percent_possible_obs                              https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.percent_possible_obs.html
        CompletenessSpherical         reflns.pdbx_percent_possible_spherical_anomalous         https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_percent_possible_spherical_anomalous.html
        CompletenessEllipsoidal       reflns.pdbx_percent_possible_ellipsoidal_anomalous       https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_percent_possible_ellipsoidal_anomalous.html
        Redundancy                    reflns.pdbx_redundancy                                   https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_redundancy.html
        CompletenessAno               reflns.pdbx_percent_possible_anomalous                   https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_percent_possible_anomalous.html
        CompletenessAnoSpherical      reflns.pdbx_percent_possible_spherical_anomalous         https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_percent_possible_spherical_anomalous.html
        CompletenessAnoEllipsoidal    reflns.pdbx_percent_possible_ellipsoidal_anomalous       https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_percent_possible_ellipsoidal_anomalous.html
        RedundancyAno                 reflns.pdbx_redundancy_anomalous                         https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_redundancy_anomalous.html

      Resolution shell (mmCIF reflns_shell category, https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.number_unique_all.html):

        R(merge)                      reflns_shell.pdbx_Rmerge_I_obs                           https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_Rmerge_I_obs.html
        R(meas)                       reflns_shell.pdbx_Rrim_I_all                             https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_Rrim_I_all.html
        R(pim)                        reflns_shell.pdbx_Rpim_I_all                             https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_Rpim_I_all.html
        I/SigI                        reflns_shell.meanI_over_sigI_obs                         https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.meanI_over_sigI_obs.html
        CC(1/2)                       reflns_shell.pdbx_CC_half                                https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_CC_half.html
        CC(ano)                       reflns_shell.pdbx_CC_half_anomalous                      https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_CC_half_anomalous.html
        SigAno                        reflns_shell.pdbx_absDiff_over_sigma_anomalous           https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_absDiff_over_sigma_anomalous.html
        Completeness                  reflns_shell.percent_possible_all                        https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.percent_possible_all.html
        CompletenessSpherical         reflns_shell.pdbx_percent_possible_spherical_anomalous   https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_percent_possible_spherical_anomalous.html
        CompletenessEllipsoidal       reflns_shell.pdbx_percent_possible_ellipsoidal_anomalous https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_percent_possible_ellipsoidal_anomalous.html
        Redundancy                    reflns_shell.pdbx_redundancy                             https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_redundancy.html
        CompletenessAno               reflns_shell.pdbx_percent_possible_anomalous             https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_percent_possible_anomalous.html
        CompletenessAnoSpherical      reflns_shell.pdbx_percent_possible_spherical_anomalous   https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_percent_possible_spherical_anomalous.html
        CompletenessAnoEllipsoidal    reflns_shell.pdbx_percent_possible_ellipsoidal_anomalous https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_percent_possible_ellipsoidal_anomalous.html
        RedundancyAno                 reflns_shell.pdbx_redundancy_anomalous                   https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_redundancy_anomalous.html

    Completeness values are given in %, 0 <= Completeness <= 100
    """

    factor_type: QualityFactorType = Field(
        ..., alias="factorType", description="Quality factor type"
    )
    value: float = Field(..., description="Quality factor value", title="Value")


class MxProcessingData(MxlimsData):
    """
    Metadata for MX Crystallographic processing calculation,

    going from images to reflection sets
    """

    mxlims_type: Literal["MXProcessing"] = Field(
        "MXProcessing",
        alias="mxlimsType",
        description="Type of MXLIMS object.",
        title="Mxlims Type",
    )
    crystal_form: Optional[CrystalForm] = Field(
        None,
        alias="crystalForm",
        description="Crystal form, with unit cell and space group, to use for processing",
    )


class CollectionSweepData(MxlimsData):
    """
    Metadata for MX  Crystallographic data collection sweep,
    may be subdivided for acquisition

     Note that the CollectionSweep specifies a single, continuous sweep range,
     with equidistant images given by imageWidth, and all starting motor positions
     in axisPositionsStart. axisPositionsEnd contain the end point of the sweep,
     and must have at least the value for the scanAxis; sweeps changing more than
     one motor (e.g. helical scan) can be represented by adding more values
     to axisPositionsEnd. The default number of images can be calculated from the
     sweep range and imageWidth. The actual number of images, the image numbering,
     and the order of acquisition (including interleaving) follows from the list of
     Scans. The role should be set to 'Result' for those sweeps that are deemed to
     be the desired result of the experiment; in templates you would prefer to use
     Acquisition for the Dataset that gives the acquisition parameters.
    """

    mxlims_type: Literal["CollectionSweep"] = Field(
        "CollectionSweep",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    annotation: Optional[str] = Field(
        None, description="Annotation string for sweep", title="Annotation"
    )
    sweep_type: Optional[str] = Field(
        "simple",
        alias="sweepType",
        description="Type of sweep: 'simple', 'mesh', 'line', 'helical, 'xray_centring'. Should be made into an enumeration",
        title="Sweep Type",
    )
    exposure_time: Optional[confloat(ge=0.0)] = Field(
        None,
        alias="exposureTime",
        description="Exposure time in seconds",
        title="Exposure Time",
    )
    image_width: Optional[confloat(ge=0.0)] = Field(
        None,
        alias="imageWidth",
        description="Width of a single image, along scanAxis. For rotational axes in degrees, for translations in mm.",
        title="Image Width",
    )
    number_images: Optional[conint(ge=0)] = Field(
        None,
        alias="numberImages",
        description="Number of images from start to end of sweep.Defines image numbering and final axis position. NB Only certain parts of the sweep may be acquired (see 'scans'),so the total number of images acquired may be less.",
        title="Number Images",
    )
    overlap: Optional[float] = Field(
        None,
        description="Overlap between successivce images, in units of imageWidth. May be negtive for non-contiguous images.",
        title="Overlap",
    )
    number_triggers: Optional[conint(ge=0)] = Field(
        None,
        alias="numberTriggers",
        description="Number of triggers. Instruction to detector - does not modify effect of other parameters.",
        title="Number Triggers",
    )
    number_images_per_trigger: Optional[conint(ge=0)] = Field(
        None,
        alias="numberImagesPerTrigger",
        description="Number of images per trigger. Instruction to detector - does not modify effect of other parameters.",
        title="Number Images Per Trigger",
    )
    number_lines: Optional[conint(ge=0)] = Field(
        None,
        alias="numberLines",
        description="Number of scanned lines used for mesh scans. Must divide numberImages",
        title="Number Lines",
    )
    mesh_range: Optional[List] = Field(
        None,
        alias="meshRange",
        description="Mesh scan range (horizontal, vertical) in mm",
        max_length=2,
        min_length=2,
        title="Mesh Range",
    )
    energy: Optional[confloat(ge=0.0)] = Field(
        None, description="Energy of the beam in eV", title="Energy"
    )
    transmission: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None, description="Transmission setting in %", title="Transmission"
    )
    resolution: Optional[float] = Field(
        None,
        description="Resolution that the sweep was intended to measureFor offset or unusual detectors this may *not* determine the detector distanceThe actual detector distance can be found in axisPositionsStart",
        title="Resolution",
    )
    detector_roi_mode: Optional[str] = Field(
        None,
        alias="detectorRoiMode",
        description="Region-of-interest mode of detector. Should be made into an enumeration",
        title="Detector Roi Mode",
    )
    beam_position: Optional[Any] = Field(
        None,
        alias="beamPosition",
        description="x,y position of the beam on the detector in pixels",
        title="Beam Position",
    )
    beam_size: Optional[List] = Field(
        None,
        alias="beamSize",
        description="x,y size of the beam on the detector in mm",
        max_length=2,
        min_length=2,
        title="Beam Size",
    )
    beam_shape: Optional[str] = Field(
        None,
        alias="beamShape",
        description="Shape of the beam. NBNB Should be an enumeration",
        examples=["unknown", "rectangular", "ellipsoid"],
        title="Beam Shape",
    )
    detector_type: Optional[str] = Field(
        None,
        alias="detectorType",
        description="Type of detector, using enumeration of mmCIF items diffrn_detector.type (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_diffrn_detector.type.html)",
        title="Detector Type",
    )
    detector_binning_mode: Optional[str] = Field(
        None,
        alias="detectorBinningMode",
        description="Binning mode of detector. Should be made into an enumeration",
        title="Detector Binning Mode",
    )
    axis_positions_start: Optional[Dict[str, float]] = Field(
        None,
        alias="axisPositionsStart",
        description="Dictionary string:float with starting position of all axes, rotations or translations, including detector distance, by name. Units are mm for distances, degrees for anglesNBNB do we use internal motor names (e.g. 'phi'), or std. names (e.g. 'omega')?",
        title="Axis Positions Start",
    )
    axis_positions_end: Optional[Dict[str, float]] = Field(
        None,
        alias="axisPositionsEnd",
        description="Dictionary string:float with final position of scanned axes as for axisPositionsStart. scanAxis position is NOT given here, but is calculated from imageWidth, overlap, numberImages, and axisPositionsStartNB scans may be acquired out of order, so this determines the limits of the sweep, not the temporal start and end points",
        title="Axis Positions End",
    )
    scan_axis: str = Field(
        ...,
        alias="scanAxis",
        description="Name of main scanned axis. Other axes may be scanned in parallel.For mesh scans name of fastest scanned axis",
        examples=[
            "omega",
            "kappa",
            "phi",
            "chi",
            "twoTheta",
            "sampleX",
            "sampleY",
            "sampleZ",
            "detectorX",
            "detectorY",
            "horizontal",
            "vertical",
        ],
        title="Scan Axis",
    )
    scans: Optional[List[Scan]] = Field(
        None,
        description="List of Scans i.e. subdivisions of CollectionSweepNB Scans need not be contiguous or in order or add up to entire sweep",
        title="Scans",
    )
    file_type: Optional[str] = Field(
        None,
        alias="fileType",
        description="Type of file.",
        examples=["mini-cbf", "imgCIF", "FullCBF", "HDF5", "MarCCD"],
        title="File Type",
    )
    prefix: Optional[str] = Field(
        None,
        description="Input parameter - used to build the fine name template.",
        title="Prefix",
    )
    filename_template: Optional[str] = Field(
        None,
        alias="filenameTemplate",
        description="File name template,  includes prefix, suffix, run number, and a slot where image number can be filled in.",
        title="Filename Template",
    )
    path: Optional[str] = Field(
        None, description="Path to directory containing image files.", title="Path"
    )


class MxExperimentData(MxlimsData):
    """
    Metadata for MX Crystallographic data acquisition experiment.
    """

    mxlims_type: Literal["MxExperiment"] = Field(
        "MxExperiment",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    experiment_strategy: Optional[str] = Field(
        None,
        alias="experimentStrategy",
        description="Experiment strategy indicator",
        examples=[
            "OSC",
            "Helical",
            "MXPressE",
            "GPhL.native.basic",
            "GPhL.SAD.advanced",
            "GPhL.2wvlMAD.basic",
        ],
        title="Experiment Strategy",
    )
    expected_resolution: Optional[confloat(ge=0.0)] = Field(
        None,
        alias="expectedResolution",
        description="The resolution expected in the experiment - for positioning the detector and setting up the experiment",
        title="Expected Resolution",
    )
    target_completeness: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        alias="targetCompleteness",
        description="Minimal completeness expected from experiment",
        title="Target Completeness",
    )
    target_multiplicity: Optional[confloat(ge=0.0)] = Field(
        None,
        alias="targetMultiplicity",
        description="Minimal multiplicity expected from experiment",
        title="Target Multiplicity",
    )
    dose_budget: Optional[confloat(ge=0.0)] = Field(
        None,
        alias="doseBudget",
        description="Dose (MGy) to be used in experiment",
        title="Dose Budget",
    )
    snapshot_count: Optional[conint(ge=0)] = Field(
        0,
        alias="snapshotCount",
        description="Number of snapshots to acquire after each (re)centring",
        title="Snapshot Count",
    )
    wedge_width: Optional[confloat(ge=0.0)] = Field(
        None,
        alias="wedgeWidth",
        description="Wedge width (in degrees) to use for interleaving",
        title="Wedge Width",
    )
    measured_flux: Optional[confloat(ge=0.0)] = Field(
        None,
        alias="measuredFlux",
        description="Measured value of beam flux in photons/s",
        title="Measured Flux",
    )
    radiation_dose: Optional[confloat(ge=0.0)] = Field(
        None,
        alias="radiationDose",
        description="Total radiation dose absorbed during experiment",
        title="Radiation Dose",
    )
    crystal_form: Optional[CrystalForm] = Field(
        None,
        alias="crystalForm",
        description="Crystal form, with unit cell and space group, as determined during characterisation",
    )


class CrystallographicSampleData(MxlimsData):
    """
    PreparedSample for crystallographic experiments
    """

    mxlims_type: Literal["CrystallographicSample"] = Field(
        "CrystallographicSample",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    macromolecule: Optional[SampleComponent] = Field(
        None, description="Macromolecule being studied - main component of the sample"
    )
    components: Optional[List[SampleComponent]] = Field(
        None, description="Other components of Sample", title="Sample components"
    )
    crystal_form: Optional[CrystalForm] = Field(
        None,
        alias="crystalForm",
        description="Crystal form, with unit cell and space group, as determined during processing",
    )
    radiation_sensitivity: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None,
        alias="radiationSensitivity",
        description="Relative radiation sensitivity of sample.",
        title="Radiation Sensitivity",
    )
    identifiers: Optional[Dict[str, str]] = Field(
        None,
        description="Dictionary str:str of contextName: identifier. ContextName will typically refer to a LIMS, database, or web site but could also be e.g. 'smiles' or 'sequence'",
        title="Identifiers",
    )


class CrystalData(MxlimsData):
    """
    Data for a Crystal or location for measuring diffraction
    """

    mxlims_type: Literal["Crystal"] = Field(
        "Crystal",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    comment: Optional[str] = Field(None, description="Comment or annotation.")


class PinPositionData(MxlimsData):
    """
    Data for a position within a pin mounted forming a slot for crystals.
    """

    mxlims_type: Literal["PinPosition"] = Field(
        "PinPosition",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    position_in_pin: conint(ge=1) = Field(
        ...,
        alias="positionInPin",
        description="The pin position within  the pin. This should be validated against the pin's numberPositions property.",
        examples=[4],
    )


class PinData(MxlimsData):
    """
    Data for a pin mounted on a puck with one or more slots for crystals.
    """

    mxlims_type: Literal["Pin"] = Field(
        "Pin",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    barcode: Optional[str] = Field(None, description="The Pin barcode or RFID code")
    number_positions: Optional[conint(ge=1)] = Field(
        1,
        alias="numberPositions",
        description="The number of positions available in the Pin.",
    )
    position_in_puck: conint(ge=1) = Field(
        ...,
        alias="positionInPuck",
        description="The puck position occupied by the pin. This should be validated against the puck's numberPositions property.",
        examples=[16],
    )


class PuckData(MxlimsData):
    """
    Data for pucks containing mounted crystals on pins.
    """

    mxlims_type: Literal["Puck"] = Field(
        "Puck",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    barcode: Optional[str] = Field(None, description="The Puck barcode or RFID code")
    number_positions: conint(ge=1) = Field(
        ...,
        alias="numberPositions",
        description="The number of pin positions available.",
    )


class TrackingDevice(BaseModel):
    """
    <p>A tracking device such as a LightBug or AirTag, included with the parent object.</p><p>Note that the tracking URLs for a given device can change, therefore implementers should use any URLs supplied rather than those cached from a previous shipment with the same device.</p>
    """

    identifier: str = Field(
        ..., description="The device serial number or other globally unique identifier."
    )
    device_type: TrackingDeviceType = Field(
        ..., alias="deviceType", description="The type of tracking device."
    )
    human_tracking_url: Optional[AnyUrl] = Field(
        None,
        alias="humanTrackingUrl",
        description="A URL where a human can, for example, see the device location on a map.",
    )
    api_tracking_url: Optional[AnyUrl] = Field(
        None,
        alias="apiTrackingUrl",
        description="A URL where a computer can, for example, obtain the device's last known latitude and longitude.",
    )


class Region(RootModel[Union[Point, Circle, Line, Rectangle, Polygon]]):
    root: Union[Point, Circle, Line, Rectangle, Polygon] = Field(
        ..., description="A region or point of interest.", title="Region"
    )


class DropImage1(BaseModel):
    """
    An image of a crystallization drop.
    """

    mime_type: ImageMimeType = Field(
        ..., alias="mimeType", description="The MIME type of the image."
    )
    light_type: Optional[ImageLightType] = Field(
        None, alias="lightType", description="The light used to capture the image."
    )
    timestamp: Optional[datetime] = Field(
        None,
        description="The date and time when the image was captured. This is to be specified in UTC and conform to ISO 8601.",
        examples=["2024-04-24T14:30:16Z", "20240424T143016Z"],
    )
    url: AnyUrl = Field(
        ...,
        description="A URL where the image can be found. It is assumed that no further authentication is needed to read this image.",
    )
    path: Optional[str] = Field(
        None,
        description="A filesystem path where the image can be found. It is assumed that both sender and receiver have permission to read the image.",
    )
    data: Optional[str] = Field(None, description="The image, UUencoded.")


class DropImage2(BaseModel):
    """
    An image of a crystallization drop.
    """

    mime_type: ImageMimeType = Field(
        ..., alias="mimeType", description="The MIME type of the image."
    )
    light_type: Optional[ImageLightType] = Field(
        None, alias="lightType", description="The light used to capture the image."
    )
    timestamp: Optional[datetime] = Field(
        None,
        description="The date and time when the image was captured. This is to be specified in UTC and conform to ISO 8601.",
        examples=["2024-04-24T14:30:16Z", "20240424T143016Z"],
    )
    url: Optional[AnyUrl] = Field(
        None,
        description="A URL where the image can be found. It is assumed that no further authentication is needed to read this image.",
    )
    path: str = Field(
        ...,
        description="A filesystem path where the image can be found. It is assumed that both sender and receiver have permission to read the image.",
    )
    data: Optional[str] = Field(None, description="The image, UUencoded.")


class DropImage3(BaseModel):
    """
    An image of a crystallization drop.
    """

    mime_type: ImageMimeType = Field(
        ..., alias="mimeType", description="The MIME type of the image."
    )
    light_type: Optional[ImageLightType] = Field(
        None, alias="lightType", description="The light used to capture the image."
    )
    timestamp: Optional[datetime] = Field(
        None,
        description="The date and time when the image was captured. This is to be specified in UTC and conform to ISO 8601.",
        examples=["2024-04-24T14:30:16Z", "20240424T143016Z"],
    )
    url: Optional[AnyUrl] = Field(
        None,
        description="A URL where the image can be found. It is assumed that no further authentication is needed to read this image.",
    )
    path: Optional[str] = Field(
        None,
        description="A filesystem path where the image can be found. It is assumed that both sender and receiver have permission to read the image.",
    )
    data: str = Field(..., description="The image, UUencoded.")


class DropImage(RootModel[Union[DropImage1, DropImage2, DropImage3]]):
    root: Union[DropImage1, DropImage2, DropImage3] = Field(
        ..., description="An image of a crystallization drop.", title="Drop image"
    )


class PlateRegion(BaseModel):
    """
    A region defined in absolute plate space.
    """

    region: Region
    units: PlateRegionUnit = Field(
        ..., description="The units of the region's co-ordinates."
    )


class WellDropData(MxlimsData):
    """
    Data for drop in a well in crystallisation plate.
    """

    mxlims_type: Literal["WellDrop"] = Field(
        "WellDrop",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    drop_number: conint(ge=1) = Field(
        ...,
        alias="dropNumber",
        description="The drop number. This should be validated against the plateType's numberSubPositions property.",
    )


class PlateWellData(MxlimsData):
    """
    Data for well in crystallisation plate.
    """

    mxlims_type: Literal["PlateWell"] = Field(
        "PlateWell",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    row_number: conint(ge=1) = Field(
        ...,
        alias="rowNumber",
        description="<The row number of this well. This is 1-based, so row A is 1, row H is 8. This should be validated against the plateType's rows property.",
    )
    column_number: conint(ge=1) = Field(
        ...,
        alias="columnNumber",
        description="<The column number of this well. This is 1-based, so should match the column labels on the plate. This should be validated against the plateType's columns property.",
    )
    name: Optional[str] = Field(
        None,
        description="A human-friendly well identifier. If present, this should be validated to ensure that it refers to the correct row and column.",
        examples=["H1", "C03"],
    )


class PlateData(MxlimsData):
    """
    Data for crystallisation plate.
    """

    mxlims_type: Literal["Plate"] = Field(
        "Plate",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    barcode: Optional[str] = Field(
        None, description="The plate barcode or otehr identifier"
    )
    plate_type: Optional[PlateType] = Field(None, alias="plateType")
    identifiers: Optional[Dict[str, str]] = Field(
        None,
        description="Dictionary str:str of contextName: identifier. ContextName will typically refer to a LIMS, database, or web site but could also be e.g. 'smiles' or 'sequence'",
        title="Identifiers",
    )
    tracking_device: Optional[TrackingDevice] = Field(None, alias="trackingDevice")


class ShipmentData(MxlimsData):
    """
    <p>Data for a shipment.</p><p>If only one of <code>labContactOutbound</code> and <code>labContactReturn</code> is present, both are assumed to be the same. If neither is present, the lab contact for both outbound and return is assumed to be the authenticated user submitting the shipment.</p>
    """

    mxlims_type: Literal["Shipment"] = Field(
        "Shipment",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    proposal_code: str = Field(
        ...,
        alias="proposalCode",
        description="The proposal number at the receiving facility.",
        examples=["mx1234"],
    )
    session_number: Optional[conint(ge=1)] = Field(
        None,
        alias="sessionNumber",
        description="The session number within the proposal. This property must be absent if <code>unattendedCollection</code> is present.",
    )
    comments: Optional[constr(max_length=250)] = Field(
        None, description="A comment about the shipment."
    )
    unattended_collection: Optional[EnumerateTrue] = Field(
        None,
        alias="unattendedCollection",
        description="If this shipment is for unattended collection, then this property must be present and true. Otherwise, it must be absent or false and a <code>session</code> must be present.",
    )
    lab_contact_outbound: Optional[Person] = Field(None, alias="labContactOutbound")
    lab_contact_return: Optional[Person] = Field(None, alias="labContactReturn")
    identifiers: Optional[Dict[str, str]] = Field(
        None,
        description="Dictionary str:str of contextName: identifier. ContextName will typically refer to a LIMS, database, or web site but could also be e.g. 'smiles' or 'sequence'",
        title="Identifiers",
    )
    tracking_device: Optional[TrackingDevice] = Field(None, alias="trackingDevice")


class MxlimsObject(BaseModel):
    """
    Base object for all MXLISM objects: Jobm, Dataset, PreparedSample, and LogisticalSample
    """

    version: Literal["0.3.0"] = Field(
        ..., description="MXLIMS version for current model", title="Version"
    )
    uuid: UUID = Field(
        ..., description="Permanent unique identifier string", title="Uuid"
    )
    data: MxlimsData = Field(
        ..., description="Metadata object, also defining the precise type."
    )
    extensions: Optional[Dict[str, Any]] = Field(
        None,
        description="Keyword-value dictionary string:Any of extensions. Use is accepted but discouraged",
        title="Extensions",
    )


class Dataset(MxlimsObject):
    """
    Base class for MXLIMS Datasets
    """

    source_id: Optional[UUID] = Field(
        None,
        alias="sourceId",
        description="String UUID of Job that created this Dataset.",
        title="Source Id",
    )
    derived_from_id: Optional[UUID] = Field(
        None,
        alias="derivedFromId",
        description="String UUID of Dataset from which this Dataset was derived. Used for modified Datasets without a 'source' link, e.g. when removing images from a sweep before processing.",
        title="Derived From Id",
    )
    role: Optional[str] = Field(
        None,
        description="Role of Dataset realtive to the source Job. Intended for filtering of Datasets",
        examples=["Result", "Intermediate", "Characterisation", "Centring"],
        title="Role",
    )
    logistical_sample_id: Optional[UUID] = Field(
        None,
        alias="logisticalSampleId",
        description="String UUID of LogisticalSample relevant to Dataset.",
        title="Logistical Sample Id",
    )


class ReflectionStatistics(BaseModel):
    """
    Reflection statistics for a shell (or all) of reflections
    """

    resolution_limits: List = Field(
        ...,
        alias="resolutionLimits",
        description="lower, higher resolution limit of shell, matches mmCIF items reflns_shell.d_res_low (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.d_res_low.html) and reflns_shell.d_res_high (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.d_res_high.html)",
        max_length=2,
        min_length=2,
        title="Resolution Limits",
    )
    number_observations: Optional[conint(ge=0)] = Field(
        None,
        alias="numberObservations",
        description="total number of observations, matches mmCIF item reflns_shell.number_measured_all (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.number_measured_all.html)",
        title="Number Observations",
    )
    number_observations_unique: Optional[conint(ge=0)] = Field(
        None,
        alias="numberObservationsUnique",
        description="total number of unique observations, matches mmCIF item reflns_shell.number_unique_all (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.number_unique_all.html)",
        title="Number Observations Unique",
    )
    number_reflections_rejected: Optional[conint(ge=0)] = Field(
        None,
        alias="numberReflectionsRejected",
        description="Number of rejected reflections within this resolution shell, matches mmCIF item reflns_shell.pdbx_rejects.html (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_rejects.html)",
        title="Number Reflections Rejected",
    )
    chi_squared: Optional[confloat(ge=0.0)] = Field(
        None,
        alias="chiSquared",
        description="Chi-squared statistic for reflection shell, matches mmCIF item reflns_shell.pdbx_chi_squared (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_chi_squared.html)",
        title="Chi Squared",
    )
    quality_factors: Optional[List[QualityFactor]] = Field(
        None,
        alias="qualityFactors",
        description="Quality factors for reflection shell, ",
        title="Quality Factors",
    )


class CollectionSweep(Dataset):
    """
    Crystallographic sweep data set, containing images
    """

    data: Optional[CollectionSweepData] = None


class PreparedSample(MxlimsObject):
    """
    Base class for MXLIMS Prepared Samples describing Sample content
    """


class DewarData(MxlimsData):
    """
    Data for dewar containing pucks with mounted crystals on pins.
    """

    mxlims_type: Literal["Dewar"] = Field(
        "Dewar",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    barcode: Optional[str] = Field(None, description="The dewar barcode or RFID code")
    tracking_device: Optional[TrackingDevice] = Field(None, alias="trackingDevice")


class ImageRegion(BaseModel):
    """
    A region marked on an image.
    """

    region: Region
    image: Optional[DropImage] = None
    units: ImageRegionUnit = Field(
        ..., description="The units of the region's co-ordinates."
    )


class Job(MxlimsObject):
    """
    Base class for MXLIMS Jobs - an experiment or calculation producing Datasets
    """

    sample_id: Optional[UUID] = Field(
        None,
        alias="sampleId",
        description="String UUID of the PreparedSample that applies to this Job",
        title="Sample Id",
    )
    logistical_sample_id: Optional[UUID] = Field(
        None,
        alias="logisticalSampleId",
        description="String UUID of LogisticalSample relevant to this Job.",
        title="Logistical Sample Id",
    )
    started_from_id: Optional[UUID] = Field(
        None,
        alias="startedFromId",
        description="String UUID of the Job from which this Job was started.",
        title="Started From Id",
    )
    start_time: Optional[datetime] = Field(
        None,
        alias="startTime",
        description="Actual starting time for job or calculation, ",
        title="Start Time",
    )
    end_time: Optional[datetime] = Field(
        None,
        alias="endTime",
        description="Actual finishing time for job or calculation, ",
        title="End Time",
    )
    job_status: Optional[JobStatus] = Field(
        None,
        alias="jobStatus",
        description="Status of job - enumerated, ",
        examples=["Template", "Ready", "Running", "Completed", "Failed", "Aborted"],
    )
    input_data_ids: Optional[List[UUID]] = Field(
        None,
        alias="inputDataIds",
        description="String UUID of input Datasets for this Job.",
        title="Input Data Ids",
    )
    reference_data_ids: Optional[List[UUID]] = Field(
        None,
        alias="referenceDataIds",
        description="String UUID of reference Datasets for this Job.",
        title="Reference Data Ids",
    )
    template_data_ids: Optional[List[UUID]] = Field(
        None,
        alias="templateDataIds",
        description="String UUID of template Datasets for this Job.",
        title="Template Data Ids",
    )
    subjobs: Optional[List[Job]] = Field(
        None,
        description="List of Jobs started from this job. NB the startedFromId of the jobs must point to this Job.This field allows attached jobs to be contained directly in the JSON file and allows for constraining job types in subtypes",
        title="Subjobs",
    )
    results: Optional[List[Dataset]] = Field(
        None,
        description="List of Datasets created from this job. NB the sourceId of the datasets must point to this Job.This field allows result Datasets to be contained directly in the JSON file and allows for constraining Dataset types in subtypes",
        title="Results",
    )
    template_data: Optional[List[Dataset]] = Field(
        None,
        alias="templateData",
        description="List of Template Datasets used for this job. NB the id of the datasets must match the IDs in templateDataIds.This field allows template Datasets to be contained directly in the JSON file and allows for constraining Dataset types in subtypes.NB Note that two different specifications of a dataset cannot have the same ID",
        title="Template Data",
    )


class ReflectionSetData(MxlimsData):
    """
    Metadata for Processed reflections, possibly merged or scaled

    as might be stored within a MTZ or mmCIF reflection file
    """

    mxlims_type: Literal["ReflectionSet"] = Field(
        "ReflectionSet",
        alias="mxlimsType",
        description="Type of MXLIMS object linked to.",
        title="Mxlims Type",
    )
    anisotropic_diffraction: Optional[bool] = Field(
        False,
        alias="anisotropicDiffraction",
        description="Is diffraction limit analysis based on anisotropic diffraction limits? True/False ",
        title="Anisotropic Diffraction",
    )
    crystal_form: Optional[CrystalForm] = Field(
        None,
        alias="crystalForm",
        description="Crystal form, with unit cell and space group, as determined during processing",
    )
    operational_resolution: Optional[float] = Field(
        None,
        alias="operationalResolution",
        description="Operational resolution (A) matching resolutionCutoffs.",
        title="Operational Resolution",
    )
    diffraction_limits_estimated: Optional[Tensor] = Field(
        None,
        alias="diffractionLimitsEstimated",
        description="Principal axes lengths (A) of ellipsoid describing reciprocal space region containing observable reflections, regardless whether all have actually been observed. Matches mmCIF items reflns.pdbx_aniso_diffraction_limit_{1,2,3} (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_aniso_diffraction_limit_1.html)",
    )
    wavelengths: Optional[List[confloat(ge=0.0)]] = Field(
        None,
        description="Wavelengths (A) at which reflections were measured",
        title="Wavelengths",
    )
    iso_b_wilson_estimate: Optional[float] = Field(
        None,
        alias="isoBWilsonEstimate",
        description="estimated (isotropic) temperature factor from slope of Wilson plot, matches mmCIF item reflns.B_iso_Wilson_estimate (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.B_iso_Wilson_estimate.html)",
        title="B Iso Wilson Estimate",
    )
    aniso_btensor: Optional[Tensor] = Field(
        None,
        alias="anisoBtensor",
        description="Anisotropic B tensor, matching mmCIF items reflns.pdbx_aniso_B_tensor_eigenvalue_{1,2,3} and reflns.pdbx_aniso_B_tensor_eigenvector_{1,2,3}_ortho[{1,2,3}] (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_aniso_B_tensor_eigenvalue_1.html)",
    )
    number_reflections: Optional[conint(ge=0)] = Field(
        None,
        alias="numberReflections",
        description="Total number of measured reflections, matches mmCIF item reflns.pdbx_number_measured_all (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_number_measured_all.html)",
        title="Number of Reflections",
    )
    number_reflections_unique: Optional[conint(ge=0)] = Field(
        None,
        alias="numberReflectionsUnique",
        description="Total number of unique reflections, matches mmCIF item reflns.number_obs (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.number_obs.html)",
        title="Number Reflections Unique",
    )
    h_index_range: Optional[List] = Field(
        None,
        alias="hIndexRange",
        description="low and high limit on Miller index h, matches mmCIF item reflns.limit_h_min (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_h_min.html) and reflns.limit_h_max (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_h_max.html)",
        max_length=2,
        min_length=2,
        title="H Index Range",
    )
    k_index_range: Optional[List] = Field(
        None,
        alias="kIndexRange",
        description="low and high limit on Miller index k, matches mmCIF item reflns.limit_k_min (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_k_min.html) and reflns.limit_k_max (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_k_max.html)",
        max_length=2,
        min_length=2,
        title="K Index Range",
    )
    l_index_range: Optional[List] = Field(
        None,
        alias="lIndexRange",
        description="low and high limit on Miller index l, matches mmCIF item reflns.limit_l_min (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_l_min.html) and reflns.limit_l_max (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_l_max.html)",
        max_length=2,
        min_length=2,
        title="L Index Range",
    )
    reflection_statistics_overall: Optional[ReflectionStatistics] = Field(
        None,
        alias="reflectionStatisticsOverall",
        description="Reflection statistics for all processed reflections",
    )
    reflection_statistics_shells: Optional[List[ReflectionStatistics]] = Field(
        None,
        alias="reflectionStatisticsShells",
        description="Reflection statistics per resolution shell",
        title="Reflection Statistics Shells",
    )
    signal_type: Optional[PdbxSignalType] = Field(
        None,
        alias="signalType",
        description="'local <I/sigmaI>', 'local wCC_half'; matches reflns.pdbx_signal_type (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_signal_type.html). Criterion for observability, as used in mmCIF refln.pdbx_signal_status (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_refln.pdbx_signal_status.html)",
    )
    signal_cutoff: Optional[float] = Field(
        None,
        alias="signalCutoff",
        description="Limiting value for signal calculation; matches reflns.pdbx_observed_signal_threshold (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_observed_signal_threshold.html). Cutoff for observability, as used in mmCIF refln.pdbx_signal_status (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_refln.pdbx_signal_status.html)",
        title="Signal Cutoff",
    )
    resolution_cutoffs: Optional[List[QualityFactor]] = Field(
        None,
        alias="resolutionCutoffs",
        description="Criteria used in determination of isotropic resolution cut-off (e.g. as implemented in MRFANA, https://github.com/githubgphl/MRFANA)",
        title="Resolution Cutoffs",
    )
    binning_mode: Optional[ReflectionBinningMode] = Field(
        None,
        alias="binningMode",
        description="Binning mode for definition of resolution shells",
    )
    number_bins: Optional[PositiveInt] = Field(
        None, alias="numberBins", description="Number of bins", title="Number Bins"
    )
    reflections_per_bin: Optional[PositiveInt] = Field(
        None,
        alias="reflectionsPerBin",
        description="Number of reflections per bin",
        title="Reflections Per Bin",
    )
    reflections_per_bin_per_sweep: Optional[PositiveInt] = Field(
        None,
        alias="reflectionsPerBinPerSweep",
        description="Number of reflections per bin per sweep (in multi-sweep experiment)",
        title="Reflections Per Bin Per Sweep",
    )
    resolution_rings_detected: Optional[List[List]] = Field(
        None,
        alias="resolutionRingsDetected",
        description="Resolution rings detected as originating from ice, powder diffraction etc.; given as a pair of floats (A) with decreasing value, i.e. low- and high-resolution limits",
        title="Resolution Rings Detected",
    )
    resolution_rings_excluded: Optional[List[List]] = Field(
        None,
        alias="resolutionRingsExcluded",
        description="Resolution rings excluded from calculation; given as a pair of floats (A) with decreasing value, i.e. low- and high-resolution limits)",
        title="Resolution Rings Excluded",
    )
    file_type: Optional[ReflectionFileType] = Field(
        None, alias="fileType", description="Type of file"
    )
    filename: Optional[str] = Field(None, description="File name.", title="Filename")
    path: Optional[str] = Field(
        None,
        description="Path to directory containing reflection set file (defined by filename).",
        title="Path",
    )


class MxExperiment(Job):
    """
    Crystallography experiment, producing data
    """

    data: Optional[MxExperimentData] = None
    results: Optional[List[CollectionSweep]] = Field(None, min_length=1)


class CrystallographicSample(PreparedSample):
    """
    Crystallographic Sample
    """

    data: Optional[CrystallographicSampleData] = None


class LogisticalSample(MxlimsObject):
    """
    Base class for MXLIMS Logistical Samples

    describing Sample containers and locations
    (from Dewars and Plates to drops, pins and crystals)
    """

    sample_id: Optional[UUID] = Field(
        None,
        alias="sampleId",
        description="String UUID of the PreparedSemple that applies to this LogisticalSample and all its contents",
        title="Sample Id",
    )
    container_id: Optional[UUID] = Field(
        None,
        alias="containerId",
        description="String UUID of the LogisticalSample containing this one",
        title="Container Id",
    )
    contents: Optional[List[LogisticalSample]] = Field(
        None,
        description="List of directly contained LogisticalSamples.NB the containerId of the contents must point to this LogisticalSample.This field allows contents to be contained directly in the JSON fileand allows for constraining content types in subtypes(E.g. Pucks can only contain contain Pins",
        title="Contents",
    )
    jobs: Optional[List[Job]] = Field(
        None,
        description="List of directly attached Jobs.NB the logisticalSampleId of the jobs must point to this LogisticalSample.This field allows attached jobs to be contained directly in the JSON fileand allows for constraining job types in subtypes",
        title="Jobs",
    )


class Crystal(LogisticalSample):
    """
    Crystal or location for measuring diffraction. Note that crystals are optional and are generally used ONLY where a region, loop, or other LogisticalSample is found to have several crystals during the actual experiment.
    """

    data: Optional[CrystalData] = None


class DropRegionData(MxlimsData):
    """
    Data for a region in a well drop where crystals may be found.
    """

    mxlims_type: Literal["DropRegion"] = Field(
        "DropRegion",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="Mxlims Type",
    )
    image_region: Optional[ImageRegion] = Field(None, alias="imageRegion")
    plate_region: Optional[PlateRegion] = Field(None, alias="plateRegion")


class ReflectionSet(Dataset):
    """
    Set of processed reflections, possibly merged or scaled, as might be stored within a MTZ or mmCIF reflection file
    """

    data: Optional[ReflectionSetData] = None


class PinPosition(LogisticalSample):
    """
    An independent Position within a Pin where crystals can be located.
    """

    data: Optional[PinPositionData] = None
    contents: Optional[List[Crystal]] = Field(None, min_length=1)


class DropRegion(LogisticalSample):
    """
    A region in a well drop where crystals may be found
    """

    data: Optional[DropRegionData] = None
    contents: Optional[List[Crystal]] = Field(None, min_length=1)


class MxProcessing(Job):
    """
    Crystallography Processing calculation,
    """

    data: Optional[MxProcessingData] = None
    results: Optional[List[ReflectionSet]] = Field(None, min_length=1)


class Pin(LogisticalSample):
    """
    A Pin mounted on a puck with one or more slots for crystals.
    """

    data: Optional[PinData] = None
    contents: Optional[List[PinPosition]] = Field(None, min_length=1)


class WellDrop(LogisticalSample):
    """
    A drop in a well in a crystallization plate
    """

    data: Optional[WellDropData] = None
    contents: Optional[List[DropRegion]] = Field(None, min_length=1)


class Puck(LogisticalSample):
    """
    A puck containing mounted crystals on pins.
    """

    data: Optional[PuckData] = None
    contents: Optional[List[Pin]] = Field(None, min_length=1)


class PlateWell(LogisticalSample):
    """
    A well in a crystallization plate
    """

    data: Optional[PlateWellData] = None
    contents: Optional[List[WellDrop]] = Field(None, min_length=1)


class Dewar(LogisticalSample):
    """
    A dewar containing pucks with mounted crystals on pins.
    """

    data: Optional[DewarData] = None
    contents: Optional[List[Puck]] = Field(None, min_length=1)


class Plate(LogisticalSample):
    """
    A crystallization plate
    """

    data: Optional[PlateData] = None
    contents: Optional[List[PlateWell]] = Field(None, min_length=1)


class Shipment(LogisticalSample):
    """
    Shipment
    """

    data: Optional[ShipmentData] = None
    contents: Optional[Union[List[Dewar], List[Plate]]] = None


class MxlimsMessage(BaseModel):
    """
    Example message for MX, showing all classes
    """

    jobs: Optional[List[Union[MxProcessing, MxExperiment]]] = Field(
        None, description="List of directly contained Jobs.", title="Jobs"
    )
    datasets: Optional[List[Union[CollectionSweep, ReflectionSet]]] = Field(
        None, description="List of directly contained Datasets.", title="Datasets"
    )
    prepared_samples: Optional[List[CrystallographicSample]] = Field(
        None,
        alias="preparedSamples",
        description="List of directly contained Prepared Samples.",
        title="Prepared Samples",
    )
    logistical_samples: Optional[List[Shipment]] = Field(
        None,
        alias="logisticalSamples",
        description="List of directly contained Logistical Samples.",
        title="Logistical Samples",
    )


Job.model_rebuild()
LogisticalSample.model_rebuild()
