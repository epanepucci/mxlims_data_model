# generated by datamodel-codegen:
#   filename:  MxlimsMessage.json
#   timestamp: 2025-01-24T17:20:30+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union
from uuid import UUID

from pydantic import (
    AnyUrl,
    BaseModel,
    Field,
    PositiveFloat,
    PositiveInt,
    RootModel,
    confloat,
    conint,
    constr,
)


class NamespacedExtension(BaseModel):
    namespace: str = Field(
        ...,
        description="Namespace string defining 'owner' of the namespace, e.g. 'ESRF, 'GPhL",
        title='Namespace',
    )


class JobStatus(Enum):
    Template = 'Template'
    Ready = 'Ready'
    Running = 'Running'
    Completed = 'Completed'
    Failed = 'Failed'
    Aborted = 'Aborted'


class UnitCell(BaseModel):
    a: confloat(ge=0.0) = Field(..., description='A axis length (A)', title='A')
    b: confloat(ge=0.0) = Field(..., description='B axis length (A)', title='B')
    c: confloat(ge=0.0) = Field(..., description='C axis length (A)', title='C')
    alpha: confloat(ge=0.0) = Field(
        ..., description='alpha angle (degree)', title='Alpha'
    )
    beta: confloat(ge=0.0) = Field(..., description='beta angle (degree)', title='Beta')
    gamma: confloat(ge=0.0) = Field(
        ..., description='gamma angle (degree)', title='Gamma'
    )


class SpacegroupNameChiral(Enum):
    P1 = 'P1'
    P2 = 'P2'
    P21 = 'P21'
    C2 = 'C2'
    P222 = 'P222'
    P2221 = 'P2221'
    P21212 = 'P21212'
    P212121 = 'P212121'
    C2221 = 'C2221'
    C222 = 'C222'
    F222 = 'F222'
    I222 = 'I222'
    I212121 = 'I212121'
    P4 = 'P4'
    P41 = 'P41'
    P42 = 'P42'
    P43 = 'P43'
    I4 = 'I4'
    I41 = 'I41'
    P422 = 'P422'
    P4212 = 'P4212'
    P4122 = 'P4122'
    P41212 = 'P41212'
    P4222 = 'P4222'
    P42212 = 'P42212'
    P4322 = 'P4322'
    P43212 = 'P43212'
    I422 = 'I422'
    I4122 = 'I4122'
    P3 = 'P3'
    P31 = 'P31'
    P32 = 'P32'
    R3 = 'R3'
    P312 = 'P312'
    P321 = 'P321'
    P3112 = 'P3112'
    P3121 = 'P3121'
    P3212 = 'P3212'
    P3221 = 'P3221'
    R32 = 'R32'
    P6 = 'P6'
    P61 = 'P61'
    P65 = 'P65'
    P62 = 'P62'
    P64 = 'P64'
    P63 = 'P63'
    P622 = 'P622'
    P6122 = 'P6122'
    P6522 = 'P6522'
    P6222 = 'P6222'
    P6422 = 'P6422'
    P6322 = 'P6322'
    P23 = 'P23'
    F23 = 'F23'
    I23 = 'I23'
    P213 = 'P213'
    I213 = 'I213'
    P432 = 'P432'
    P4232 = 'P4232'
    F432 = 'F432'
    F4132 = 'F4132'
    I432 = 'I432'
    P4332 = 'P4332'
    P4132 = 'P4132'
    I4132 = 'I4132'


class SpacegroupName(Enum):
    P1 = 'P1'
    P_1 = 'P 1'
    P_1_1 = 'P-1'
    P__1 = 'P -1'
    P2 = 'P2'
    P_1_2_1 = 'P 1 2 1'
    P121 = 'P121'
    P_2 = 'P 2'
    P21 = 'P21'
    P_1_21_1 = 'P 1 21 1'
    P1211 = 'P1211'
    P_21 = 'P 21'
    C2 = 'C2'
    C_1_2_1 = 'C 1 2 1'
    C121 = 'C121'
    C_2 = 'C 2'
    Pm = 'Pm'
    P_1_m_1 = 'P 1 m 1'
    P1m1 = 'P1m1'
    P_m = 'P m'
    Pc = 'Pc'
    P_1_c_1 = 'P 1 c 1'
    P1c1 = 'P1c1'
    P_c = 'P c'
    Cm = 'Cm'
    C_1_m_1 = 'C 1 m 1'
    C1m1 = 'C1m1'
    C_m = 'C m'
    Cc = 'Cc'
    C_1_c_1 = 'C 1 c 1'
    C1c1 = 'C1c1'
    C_c = 'C c'
    P2_m = 'P2/m'
    P_1_2_m_1 = 'P 1 2/m 1'
    P12_m1 = 'P12/m1'
    P_2_m = 'P 2/m'
    P21_m = 'P21/m'
    P_1_21_m_1 = 'P 1 21/m 1'
    P121_m1 = 'P121/m1'
    P_21_m = 'P 21/m'
    C2_m = 'C2/m'
    C_1_2_m_1 = 'C 1 2/m 1'
    C12_m1 = 'C12/m1'
    C_2_m = 'C 2/m'
    P2_c = 'P2/c'
    P_1_2_c_1 = 'P 1 2/c 1'
    P12_c1 = 'P12/c1'
    P_2_c = 'P 2/c'
    P21_c = 'P21/c'
    P_1_21_c_1 = 'P 1 21/c 1'
    P121_c1 = 'P121/c1'
    P_21_c = 'P 21/c'
    C2_c = 'C2/c'
    C_1_2_c_1 = 'C 1 2/c 1'
    C12_c1 = 'C12/c1'
    C_2_c = 'C 2/c'
    P222 = 'P222'
    P_2_2_2 = 'P 2 2 2'
    P2221 = 'P2221'
    P_2_2_21 = 'P 2 2 21'
    P2212 = 'P2212'
    P_2_21_2 = 'P 2 21 2'
    P2122 = 'P2122'
    P_21_2_2 = 'P 21 2 2'
    P21212 = 'P21212'
    P_21_21_2 = 'P 21 21 2'
    P21221 = 'P21221'
    P_21_2_21 = 'P 21 2 21'
    P22121 = 'P22121'
    P_2_21_21 = 'P 2 21 21'
    P212121 = 'P212121'
    P_21_21_21 = 'P 21 21 21'
    C2221 = 'C2221'
    C_2_2_21 = 'C 2 2 21'
    C222 = 'C222'
    C_2_2_2 = 'C 2 2 2'
    F222 = 'F222'
    F_2_2_2 = 'F 2 2 2'
    I222 = 'I222'
    I_2_2_2 = 'I 2 2 2'
    I212121 = 'I212121'
    I_21_21_21 = 'I 21 21 21'
    Pmm2 = 'Pmm2'
    P_m_m_2 = 'P m m 2'
    Pmc21 = 'Pmc21'
    P_m_c_21 = 'P m c 21'
    Pcc2 = 'Pcc2'
    P_c_c_2 = 'P c c 2'
    Pma2 = 'Pma2'
    P_m_a_2 = 'P m a 2'
    Pca21 = 'Pca21'
    P_c_a_21 = 'P c a 21'
    Pnc2 = 'Pnc2'
    P_n_c_2 = 'P n c 2'
    Pmn21 = 'Pmn21'
    P_m_n_21 = 'P m n 21'
    Pba2 = 'Pba2'
    P_b_a_2 = 'P b a 2'
    Pna21 = 'Pna21'
    P_n_a_21 = 'P n a 21'
    Pnn2 = 'Pnn2'
    P_n_n_2 = 'P n n 2'
    Cmm2 = 'Cmm2'
    C_m_m_2 = 'C m m 2'
    Cmc21 = 'Cmc21'
    C_m_c_21 = 'C m c 21'
    Ccc2 = 'Ccc2'
    C_c_c_2 = 'C c c 2'
    Amm2 = 'Amm2'
    A_m_m_2 = 'A m m 2'
    Abm2 = 'Abm2'
    A_b_m_2 = 'A b m 2'
    Ama2 = 'Ama2'
    A_m_a_2 = 'A m a 2'
    Aba2 = 'Aba2'
    A_b_a_2 = 'A b a 2'
    Fmm2 = 'Fmm2'
    F_m_m_2 = 'F m m 2'
    Fdd2 = 'Fdd2'
    F_d_d_2 = 'F d d 2'
    Imm2 = 'Imm2'
    I_m_m_2 = 'I m m 2'
    Iba2 = 'Iba2'
    I_b_a_2 = 'I b a 2'
    Ima2 = 'Ima2'
    I_m_a_2 = 'I m a 2'
    Pmmm = 'Pmmm'
    P_2_m_2_m_2_m = 'P 2/m 2/m 2/m'
    P2_m2_m2_m = 'P2/m2/m2/m'
    P_m_m_m = 'P m m m'
    Pnnn = 'Pnnn'
    P_2_n_2_n_2_n = 'P 2/n 2/n 2/n'
    P2_n2_n2_n = 'P2/n2/n2/n'
    P_n_n_n = 'P n n n'
    Pccm = 'Pccm'
    P_2_c_2_c_2_m = 'P 2/c 2/c 2/m'
    P2_c2_c2_m = 'P2/c2/c2/m'
    P_c_c_m = 'P c c m'
    Pban = 'Pban'
    P_2_b_2_a_2_n = 'P 2/b 2/a 2/n'
    P2_b2_a2_n = 'P2/b2/a2/n'
    P_b_a_n = 'P b a n'
    Pmma = 'Pmma'
    P_21_m_2_m_2_a = 'P 21/m 2/m 2/a'
    P21_m2_m2_a = 'P21/m2/m2/a'
    P_m_m_a = 'P m m a'
    Pnna = 'Pnna'
    P_2_n_21_n_2_a = 'P 2/n 21/n 2/a'
    P2_n21_n2_a = 'P2/n21/n2/a'
    P_n_n_a = 'P n n a'
    Pmna = 'Pmna'
    P_2_m_2_n_21_a = 'P 2/m 2/n 21/a'
    P2_m2_n21_a = 'P2/m2/n21/a'
    P_m_n_a = 'P m n a'
    Pcca = 'Pcca'
    P_21_c_2_c_2_a = 'P 21/c 2/c 2/a'
    P21_c2_c2_a = 'P21/c2/c2/a'
    P_c_c_a = 'P c c a'
    Pbam = 'Pbam'
    P_21_b_21_a_2_m = 'P 21/b 21/a 2/m'
    P21_b21_a2_m = 'P21/b21/a2/m'
    P_b_a_m = 'P b a m'
    Pccn = 'Pccn'
    P_21_c_21_c_2_n = 'P 21/c 21/c 2/n'
    P21_c21_c2_n = 'P21/c21/c2/n'
    P_c_c_n = 'P c c n'
    Pbcm = 'Pbcm'
    P_2_b_21_c_21_m = 'P 2/b 21/c 21/m'
    P2_b21_c21_m = 'P2/b21/c21/m'
    P_b_c_m = 'P b c m'
    Pnnm = 'Pnnm'
    P_21_n_21_n_2_m = 'P 21/n 21/n 2/m'
    P21_n21_n2_m = 'P21/n21/n2/m'
    P_n_n_m = 'P n n m'
    Pmmn = 'Pmmn'
    P_21_m_21_m_2_n = 'P 21/m 21/m 2/n'
    P21_m21_m2_n = 'P21/m21/m2/n'
    P_m_m_n = 'P m m n'
    Pbcn = 'Pbcn'
    P_21_b_2_c_21_n = 'P 21/b 2/c 21/n'
    P21_b2_c21_n = 'P21/b2/c21/n'
    P_b_c_n = 'P b c n'
    Pbca = 'Pbca'
    P_21_b_21_c_21_a = 'P 21/b 21/c 21/a'
    P21_b21_c21_a = 'P21/b21/c21/a'
    P_b_c_a = 'P b c a'
    Pnma = 'Pnma'
    P_21_n_21_m_21_a = 'P 21/n 21/m 21/a'
    P21_n21_m21_a = 'P21/n21/m21/a'
    P_n_m_a = 'P n m a'
    Cmcm = 'Cmcm'
    C_2_m_2_c_21_m = 'C 2/m 2/c 21/m'
    C2_m2_c21_m = 'C2/m2/c21/m'
    C_m_c_m = 'C m c m'
    Cmca = 'Cmca'
    C_2_m_2_c_21_a = 'C 2/m 2/c 21/a'
    C2_m2_c21_a = 'C2/m2/c21/a'
    C_m_c_a = 'C m c a'
    Cmmm = 'Cmmm'
    C_2_m_2_m_2_m = 'C 2/m 2/m 2/m'
    C2_m2_m2_m = 'C2/m2/m2/m'
    C_m_m_m = 'C m m m'
    Cccm = 'Cccm'
    C_2_c_2_c_2_m = 'C 2/c 2/c 2/m'
    C2_c2_c2_m = 'C2/c2/c2/m'
    C_c_c_m = 'C c c m'
    Cmma = 'Cmma'
    C_2_m_2_m_2_a = 'C 2/m 2/m 2/a'
    C2_m2_m2_a = 'C2/m2/m2/a'
    C_m_m_a = 'C m m a'
    Ccca = 'Ccca'
    C_2_c_2_c_2_a = 'C 2/c 2/c 2/a'
    C2_c2_c2_a = 'C2/c2/c2/a'
    C_c_c_a = 'C c c a'
    Fmmm = 'Fmmm'
    F_2_m_2_m_2_m = 'F 2/m 2/m 2/m'
    F2_m2_m2_m = 'F2/m2/m2/m'
    F_m_m_m = 'F m m m'
    Fddd = 'Fddd'
    F_2_d_2_d_2_d = 'F 2/d 2/d 2/d'
    F2_d2_d2_d = 'F2/d2/d2/d'
    F_d_d_d = 'F d d d'
    Immm = 'Immm'
    I_2_m_2_m_2_m = 'I 2/m 2/m 2/m'
    I2_m2_m2_m = 'I2/m2/m2/m'
    I_m_m_m = 'I m m m'
    Ibam = 'Ibam'
    I_2_b_2_a_2_m = 'I 2/b 2/a 2/m'
    I2_b2_a2_m = 'I2/b2/a2/m'
    I_b_a_m = 'I b a m'
    Ibca = 'Ibca'
    I_21_b_21_c_21_a = 'I 21/b 21/c 21/a'
    I21_b21_c21_a = 'I21/b21/c21/a'
    I_b_c_a = 'I b c a'
    Imma = 'Imma'
    I_21_m_21_m_21_a = 'I 21/m 21/m 21/a'
    I21_m21_m21_a = 'I21/m21/m21/a'
    I_m_m_a = 'I m m a'
    P4 = 'P4'
    P_4 = 'P 4'
    P41 = 'P41'
    P_41 = 'P 41'
    P42 = 'P42'
    P_42 = 'P 42'
    P43 = 'P43'
    P_43 = 'P 43'
    I4 = 'I4'
    I_4 = 'I 4'
    I41 = 'I41'
    I_41 = 'I 41'
    P_4_1 = 'P-4'
    P__4 = 'P -4'
    I_4_1 = 'I-4'
    I__4 = 'I -4'
    P4_m = 'P4/m'
    P_4_m = 'P 4/m'
    P42_m = 'P42/m'
    P_42_m = 'P 42/m'
    P4_n = 'P4/n'
    P_4_n = 'P 4/n'
    P42_n = 'P42/n'
    P_42_n = 'P 42/n'
    I4_m = 'I4/m'
    I_4_m = 'I 4/m'
    I41_a = 'I41/a'
    I_41_a = 'I 41/a'
    P422 = 'P422'
    P_4_2_2 = 'P 4 2 2'
    P4212 = 'P4212'
    P_4_21_2 = 'P 4 21 2'
    P4122 = 'P4122'
    P_41_2_2 = 'P 41 2 2'
    P41212 = 'P41212'
    P_41_21_2 = 'P 41 21 2'
    P4222 = 'P4222'
    P_42_2_2 = 'P 42 2 2'
    P42212 = 'P42212'
    P_42_21_2 = 'P 42 21 2'
    P4322 = 'P4322'
    P_43_2_2 = 'P 43 2 2'
    P43212 = 'P43212'
    P_43_21_2 = 'P 43 21 2'
    I422 = 'I422'
    I_4_2_2 = 'I 4 2 2'
    I4122 = 'I4122'
    I_41_2_2 = 'I 41 2 2'
    P4mm = 'P4mm'
    P_4_m_m = 'P 4 m m'
    P4bm = 'P4bm'
    P_4_b_m = 'P 4 b m'
    P42cm = 'P42cm'
    P_42_c_m = 'P 42 c m'
    P42nm = 'P42nm'
    P_42_n_m = 'P 42 n m'
    P4cc = 'P4cc'
    P_4_c_c = 'P 4 c c'
    P4nc = 'P4nc'
    P_4_n_c = 'P 4 n c'
    P42mc = 'P42mc'
    P_42_m_c = 'P 42 m c'
    P42bc = 'P42bc'
    P_42_b_c = 'P 42 b c'
    I4mm = 'I4mm'
    I_4_m_m = 'I 4 m m'
    I4cm = 'I4cm'
    I_4_c_m = 'I 4 c m'
    I41md = 'I41md'
    I_41_m_d = 'I 41 m d'
    I41cd = 'I41cd'
    I_41_c_d = 'I 41 c d'
    P_42m = 'P-42m'
    P__4_2_m = 'P -4 2 m'
    P_42c = 'P-42c'
    P__4_2_c = 'P -4 2 c'
    P_421m = 'P-421m'
    P__4_21_m = 'P -4 21 m'
    P_421c = 'P-421c'
    P__4_21_c = 'P -4 21 c'
    P_4m2 = 'P-4m2'
    P__4_m_2 = 'P -4 m 2'
    P_4c2 = 'P-4c2'
    P__4_c_2 = 'P -4 c 2'
    P_4b2 = 'P-4b2'
    P__4_b_2 = 'P -4 b 2'
    P_4n2 = 'P-4n2'
    P__4_n_2 = 'P -4 n 2'
    I_4m2 = 'I-4m2'
    I__4_m_2 = 'I -4 m 2'
    I_4c2 = 'I-4c2'
    I__4_c_2 = 'I -4 c 2'
    I_42m = 'I-42m'
    I__4_2_m = 'I -4 2 m'
    I_42d = 'I-42d'
    I__4_2_d = 'I -4 2 d'
    P4_mmm = 'P4/mmm'
    P_4_m_2_m_2_m = 'P 4/m 2/m 2/m'
    P4_m2_m2_m = 'P4/m2/m2/m'
    P4_m_m_m = 'P4/m m m'
    P4_mcc = 'P4/mcc'
    P_4_m_2_c_2_c = 'P 4/m 2/c 2/c'
    P4_m2_c2_c = 'P4/m2/c2/c'
    P4_m_c_c = 'P4/m c c'
    P4_nbm = 'P4/nbm'
    P_4_n_2_b_2_m = 'P 4/n 2/b 2/m'
    P4_n2_b2_m = 'P4/n2/b2/m'
    P4_n_b_m = 'P4/n b m'
    P4_nnc = 'P4/nnc'
    P_4_n_2_n_2_c = 'P 4/n 2/n 2/c'
    P4_n2_n2_c = 'P4/n2/n2/c'
    P4_n_n_c = 'P4/n n c'
    P4_mbm = 'P4/mbm'
    P_4_m_21_b_2_m = 'P 4/m 21/b 2/m'
    P4_m21_b2_m = 'P4/m21/b2/m'
    P4_m_b_m = 'P4/m b m'
    P4_mnc = 'P4/mnc'
    P_4_m_21_n_2_c = 'P 4/m 21/n 2/c'
    P4_m21_n2_c = 'P4/m21/n2/c'
    P4_m_n_c = 'P4/m n c'
    P4_nmm = 'P4/nmm'
    P_4_n_21_m_2_m = 'P 4/n 21/m 2/m'
    P4_n21_m2_m = 'P4/n21/m2/m'
    P4_n_m_m = 'P4/n m m'
    P4_ncc = 'P4/ncc'
    P_4_n_2_c_2_c = 'P 4/n 2/c 2/c'
    P4_n2_c2_c = 'P4/n2/c2/c'
    P4_n_c_c = 'P4/n c c'
    P42_mmc = 'P42/mmc'
    P_42_m_2_m_2_c = 'P 42/m 2/m 2/c'
    P42_m2_m2_c = 'P42/m2/m2/c'
    P42_m_m_c = 'P42/m m c'
    P42_mcm = 'P42/mcm'
    P_42_m_2_c_2_m = 'P 42/m 2/c 2/m'
    P42_m2_c2_m = 'P42/m2/c2/m'
    P42_m_c_m = 'P42/m c m'
    P42_nbc = 'P42/nbc'
    P_42_n_2_b_2_c = 'P 42/n 2/b 2/c'
    P42_n2_b2_c = 'P42/n2/b2/c'
    P42_n_b_c = 'P42/n b c'
    P42_nnm = 'P42/nnm'
    P_42_n_2_n_2_m = 'P 42/n 2/n 2/m'
    P42_n2_n2_m = 'P42/n2/n2/m'
    P42_n_n_m = 'P42/n n m'
    P42_mbc = 'P42/mbc'
    P_42_m_21_b_2_c = 'P 42/m 21/b 2/c'
    P42_m21_b2_c = 'P42/m21/b2/c'
    P42_m_b_c = 'P42/m b c'
    P42_mnm = 'P42/mnm'
    P_42_m_21_n_2_m = 'P 42/m 21/n 2/m'
    P42_m21_n2_m = 'P42/m21/n2/m'
    P42_m_n_m = 'P42/m n m'
    P42_nmc = 'P42/nmc'
    P_42_n_21_m_2_c = 'P 42/n 21/m 2/c'
    P42_n21_m2_c = 'P42/n21/m2/c'
    P42_n_m_c = 'P42/n m c'
    P42_ncm = 'P42/ncm'
    P_42_n_21_c_2_m = 'P 42/n 21/c 2/m'
    P42_n21_c2_m = 'P42/n21/c2/m'
    P42_n_c_m = 'P42/n c m'
    I4_mmm = 'I4/mmm'
    I_4_m_2_m_2_m = 'I 4/m 2/m 2/m'
    I4_m2_m2_m = 'I4/m2/m2/m'
    I4_m_m_m = 'I4/m m m'
    I4_mcm = 'I4/mcm'
    I_4_m_2_c_2_m = 'I 4/m 2/c 2/m'
    I4_m2_c2_m = 'I4/m2/c2/m'
    I4_m_c_m = 'I4/m c m'
    I41_amd = 'I41/amd'
    I_41_a_2_m_2_d = 'I 41/a 2/m 2/d'
    I41_a2_m2_d = 'I41/a2/m2/d'
    I41_a_m_d = 'I41/a m d'
    I41_acd = 'I41/acd'
    I_41_a_2_c_2_d = 'I 41/a 2/c 2/d'
    I41_a2_c2_d = 'I41/a2/c2/d'
    I41_a_c_d = 'I41/a c d'
    P3 = 'P3'
    P_3 = 'P 3'
    P31 = 'P31'
    P_31 = 'P 31'
    P32 = 'P32'
    P_32 = 'P 32'
    R3 = 'R3'
    H_3 = 'H 3'
    H3 = 'H3'
    field_R_3 = ' R 3'
    P_3_1 = 'P-3'
    P__3 = 'P -3'
    R_3 = 'R-3'
    H__3 = 'H -3'
    H_3_1 = 'H-3'
    R__3 = 'R -3'
    P312 = 'P312'
    P_3_1_2 = 'P 3 1 2'
    P321 = 'P321'
    P_3_2_1 = 'P 3 2 1'
    P3112 = 'P3112'
    P_31_1_2 = 'P 31 1 2'
    P3121 = 'P3121'
    P_31_2_1 = 'P 31 2 1'
    P3212 = 'P3212'
    P_32_1_2 = 'P 32 1 2'
    P3221 = 'P3221'
    P_32_2_1 = 'P 32 2 1'
    R32 = 'R32'
    H_3_2 = 'H 3 2'
    H32 = 'H32'
    R_3_2 = 'R 3 2'
    P3m1 = 'P3m1'
    P_3_m_1 = 'P 3 m 1'
    P31m = 'P31m'
    P_3_1_m = 'P 3 1 m'
    P3c1 = 'P3c1'
    P_3_c_1 = 'P 3 c 1'
    P31c = 'P31c'
    P_3_1_c = 'P 3 1 c'
    R3m = 'R3m'
    H_3_m = 'H 3 m'
    H3m = 'H3m'
    R_3_m = 'R 3 m'
    R3c = 'R3c'
    H_3_c = 'H 3 c'
    H3c = 'H3c'
    R_3_c = 'R 3 c'
    P_31m = 'P-31m'
    P__3_1_2_m = 'P -3 1 2/m'
    P_312_m = 'P-312/m'
    P__3_1_m = 'P -3 1 m'
    P_31c = 'P-31c'
    P__3_1_2_c = 'P -3 1 2/c'
    P_312_c = 'P-312/c'
    P__3_1_c = 'P -3 1 c'
    P_3m1 = 'P-3m1'
    P__3_2_m_1 = 'P -3 2/m 1'
    P_32_m1 = 'P-32/m1'
    P__3_m_1 = 'P -3 m 1'
    P_3c1 = 'P-3c1'
    P__3_2_c_1 = 'P -3 2/c 1'
    P_32_c1 = 'P-32/c1'
    P__3_c_1 = 'P -3 c 1'
    R_3m = 'R-3m'
    H_3m = 'H-3m'
    H__3_2_m = 'H -3 2/m'
    H_32_m = 'H-32/m'
    H__3_m = 'H -3 m'
    R__3_2_m = 'R -3 2/m'
    R_32_m = 'R-32/m'
    R__3_m = 'R -3 m'
    R_3c = 'R-3c'
    H_3c = 'H-3c'
    H__3_2_c = 'H -3 2/c'
    H_32_c = 'H-32/c'
    H__3_c = 'H -3 c'
    R__3_2_c = 'R -3 2/c'
    R_32_c = 'R-32/c'
    R__3_c = 'R -3 c'
    P6 = 'P6'
    P_6 = 'P 6'
    P61 = 'P61'
    P_61 = 'P 61'
    P65 = 'P65'
    P_65 = 'P 65'
    P62 = 'P62'
    P_62 = 'P 62'
    P64 = 'P64'
    P_64 = 'P 64'
    P63 = 'P63'
    P_63 = 'P 63'
    P_6_1 = 'P-6'
    P__6 = 'P -6'
    P6_m = 'P6/m'
    P_6_m = 'P 6/m'
    P63_m = 'P63/m'
    P_63_m = 'P 63/m'
    P622 = 'P622'
    P_6_2_2 = 'P 6 2 2'
    P6122 = 'P6122'
    P_61_2_2 = 'P 61 2 2'
    P6522 = 'P6522'
    P_65_2_2 = 'P 65 2 2'
    P6222 = 'P6222'
    P_62_2_2 = 'P 62 2 2'
    P6422 = 'P6422'
    P_64_2_2 = 'P 64 2 2'
    P6322 = 'P6322'
    P_63_2_2 = 'P 63 2 2'
    P6mm = 'P6mm'
    P_6_m_m = 'P 6 m m'
    P6cc = 'P6cc'
    P_6_c_c = 'P 6 c c'
    P63cm = 'P63cm'
    P_63_c_m = 'P 63 c m'
    P63mc = 'P63mc'
    P_63_m_c = 'P 63 m c'
    P_6m2 = 'P-6m2'
    P__6_m_2 = 'P -6 m 2'
    P_6c2 = 'P-6c2'
    P__6_c_2 = 'P -6 c 2'
    P_62m = 'P-62m'
    P__6_2_m = 'P -6 2 m'
    P_62c = 'P-62c'
    P__6_2_c = 'P -6 2 c'
    P6_mmm = 'P6/mmm'
    P_6_m_2_m_2_m = 'P 6/m 2/m 2/m'
    P6_m2_m2_m = 'P6/m2/m2/m'
    P_6_m_m_m = 'P 6/m m m'
    P6_mcc = 'P6/mcc'
    P_6_m_2_c_2_c = 'P 6/m 2/c 2/c'
    P6_m2_c2_c = 'P6/m2/c2/c'
    P_6_m_c_c = 'P 6/m c c'
    P63_mcm = 'P63/mcm'
    P_63_m_2_c_2_m = 'P 63/m 2/c 2/m'
    P63_m2_c2_m = 'P63/m2/c2/m'
    P_63_m_c_m = 'P 63/m c m'
    P63_mmc = 'P63/mmc'
    P_63_m_2_m_2_c = 'P 63/m 2/m 2/c'
    P63_m2_m2_c = 'P63/m2/m2/c'
    P_63_m_m_c = 'P 63/m m c'
    P23 = 'P23'
    P_2_3 = 'P 2 3'
    F23 = 'F23'
    F_2_3 = 'F 2 3'
    I23 = 'I23'
    I_2_3 = 'I 2 3'
    P213 = 'P213'
    P_21_3 = 'P 21 3'
    I213 = 'I213'
    I_21_3 = 'I 21 3'
    Pm_3 = 'Pm-3'
    P_2_m__3 = 'P 2/m -3'
    P2_m_3 = 'P2/m-3'
    P_m__3 = 'P m -3'
    Pn_3 = 'Pn-3'
    P_2_n__3 = 'P 2/n -3'
    P2_n_3 = 'P2/n-3'
    P_n__3 = 'P n -3'
    Fm_3 = 'Fm-3'
    F_2_m__3 = 'F 2/m -3'
    F2_m_3 = 'F2/m-3'
    F_m__3 = 'F m -3'
    Fd_3 = 'Fd-3'
    F_2_d__3 = 'F 2/d -3'
    F2_d_3 = 'F2/d-3'
    F_d__3 = 'F d -3'
    Im_3 = 'Im-3'
    I_2_m__3 = 'I 2/m -3'
    I2_m_3 = 'I2/m-3'
    I_m__3 = 'I m -3'
    Pa_3 = 'Pa-3'
    P_21_a__3 = 'P 21/a -3'
    P21_a_3 = 'P21/a-3'
    P_a__3 = 'P a -3'
    Ia_3 = 'Ia-3'
    I_21_a__3 = 'I 21/a -3'
    I21_a_3 = 'I21/a-3'
    I_a__3 = 'I a -3'
    P432 = 'P432'
    P_4_3_2 = 'P 4 3 2'
    P4232 = 'P4232'
    P_42_3_2 = 'P 42 3 2'
    F432 = 'F432'
    F_4_3_2 = 'F 4 3 2'
    F4132 = 'F4132'
    F_41_3_2 = 'F 41 3 2'
    I432 = 'I432'
    I_4_3_2 = 'I 4 3 2'
    P4332 = 'P4332'
    P_43_3_2 = 'P 43 3 2'
    P4132 = 'P4132'
    P_41_3_2 = 'P 41 3 2'
    I4132 = 'I4132'
    I_41_3_2 = 'I 41 3 2'
    P_43m = 'P-43m'
    P__4_3_m = 'P -4 3 m'
    F_43m = 'F-43m'
    F__4_3_m = 'F -4 3 m'
    I_43m = 'I-43m'
    I__4_3_m = 'I -4 3 m'
    P_43n = 'P-43n'
    P__4_3_n = 'P -4 3 n'
    F_43c = 'F-43c'
    F__4_3_c = 'F -4 3 c'
    I_43d = 'I-43d'
    I__4_3_d = 'I -4 3 d'
    Pm_3m = 'Pm-3m'
    P_4_m__3_2_m = 'P 4/m -3 2/m'
    P4_m_32_m = 'P4/m-32/m'
    P_m__3_m = 'P m -3 m'
    Pn_3n = 'Pn-3n'
    P_4_n__3_2_n = 'P 4/n -3 2/n'
    P4_n_32_n = 'P4/n-32/n'
    P_n__3_n = 'P n -3 n'
    Pm_3n = 'Pm-3n'
    P_42_m__3_2_n = 'P 42/m -3 2/n'
    P42_m_32_n = 'P42/m-32/n'
    P_m__3_n = 'P m -3 n'
    Pn_3m = 'Pn-3m'
    P_42_n__3_2_m = 'P 42/n -3 2/m'
    P42_n_32_m = 'P42/n-32/m'
    P_n__3_m = 'P n -3 m'
    Fm_3m = 'Fm-3m'
    F_4_m__3_2_m = 'F 4/m -3 2/m'
    F4_m_32_m = 'F4/m-32/m'
    F_m__3_m = 'F m -3 m'
    Fm_3c = 'Fm-3c'
    F_4_m__3_2_c = 'F 4/m -3 2/c'
    F4_m_32_c = 'F4/m-32/c'
    F_m__3_c = 'F m -3 c'
    Fd_3m = 'Fd-3m'
    F_41_d__3_2_m = 'F 41/d -3 2/m'
    F41_d_32_m = 'F41/d-32/m'
    F_d__3_m = 'F d -3 m'
    Fd_3c = 'Fd-3c'
    F_41_d__3_2_c = 'F 41/d -3 2/c'
    F41_d_32_c = 'F41/d-32/c'
    F_d__3_c = 'F d -3 c'
    Im_3m = 'Im-3m'
    I_4_m__3_2_m = 'I 4/m -3 2/m'
    I4_m_32_m = 'I4/m-32/m'
    I_m__3_m = 'I m -3 m'
    Ia_3d = 'Ia-3d'
    I_41_a__3_2_d = 'I 41/a -3 2/d'
    I41_a_32_d = 'I41/a-32/d'
    I_a__3_d = 'I a -3 d'


class Tensor(BaseModel):
    eigenvalues: List = Field(
        ...,
        description='Eigenvalues of tensor',
        max_length=3,
        min_length=3,
        title='Eigenvalues',
    )
    eigenvectors: List[List] = Field(
        ...,
        description='Eigenvectors (unit vectors) of tensor, in same order as eigenvalues',
        title='Eigenvectors',
    )


class PdbxSignalType(Enum):
    local__I_sigmaI_ = 'local <I/sigmaI>'
    local_wCC_half = 'local wCC_half'


class QualityFactorType(Enum):
    R_merge_ = 'R(merge)'
    R_meas_ = 'R(meas)'
    R_pim_ = 'R(pim)'
    I_SigI = 'I/SigI'
    CC_1_2_ = 'CC(1/2)'
    CC_ano_ = 'CC(ano)'
    SigAno = 'SigAno'
    Completeness = 'Completeness'
    CompletenessSpherical = 'CompletenessSpherical'
    CompletenessEllipsoidal = 'CompletenessEllipsoidal'
    Redundancy = 'Redundancy'
    CompletenessAno = 'CompletenessAno'
    CompletenessAnoSpherical = 'CompletenessAnoSpherical'
    CompletenessAnoEllipsoidal = 'CompletenessAnoEllipsoidal'
    RedundancyAno = 'RedundancyAno'


class ReflectionBinningMode(Enum):
    equal_volume = 'equal_volume'
    equal_number = 'equal_number'
    dstar_equidistant = 'dstar_equidistant'
    dstar2_equidistant = 'dstar2_equidistant'


class ReflectionFileType(Enum):
    scaled_and_merged_MTZ = 'scaled and merged MTZ'
    scaled_and_unmerged_MTZ = 'scaled and unmerged MTZ'
    unmerged_MTZ = 'unmerged MTZ'
    XDS_INTEGRATE_HKL__unmerged__https___xds_mr_mpg_de_html_doc_xds_files_html_INTEGRATE_HKL_ = 'XDS INTEGRATE.HKL; unmerged (https://xds.mr.mpg.de/html_doc/xds_files.html#INTEGRATE.HKL)'
    XDS_XDS_ASCII_HKL__scaled_and_unmerged__https___xds_mr_mpg_de_html_doc_xds_files_html_XDS_ASCII_HKL_ = 'XDS XDS_ASCII.HKL; scaled and unmerged (https://xds.mr.mpg.de/html_doc/xds_files.html#XDS_ASCII.HKL)'


class Scan(BaseModel):
    scan_position_start: float = Field(
        ...,
        description='Value of scan axis for the first image, in units matching axis type',
        title='Scan Position Start',
    )
    first_image_number: int = Field(
        ...,
        description='Image number to use for first image',
        title='First Image Number',
    )
    number_images: conint(ge=0) = Field(
        ...,
        description='Number of images to acquire as part of the Scan.',
        title='Number Images',
    )
    ordinal: int = Field(
        ...,
        description='Ordinal defining the ordering of all scans within the experiment (not just within the scan)',
        title='Ordinal',
    )


class SampleComponent(BaseModel):
    acronym: Optional[str] = Field(
        None,
        description="Acronynm - short synonym of component (e.g. 'lig1'",
        title='Acronym',
    )
    name: Optional[str] = Field(
        None, description='Human readable name of component', title='Name'
    )
    role: Optional[str] = Field(
        None,
        description='Role of component in PreparedSample',
        examples=['solvent', 'cryoprotectant', 'ligand', 'inhibitor', 'target'],
        title='Role',
    )
    identifiers: Optional[Dict[str, str]] = Field(
        None,
        description="Dictionary str:str of contextName: identifier. ContextName will typically refer to a LIMS, database, or web site but could also be e.g. 'smiles' or 'sequence'",
        title='Identifiers',
    )


class DeviceType(Enum):
    LightBug = 'LightBug'
    AirTag = 'AirTag'
    other = 'other'


class TrackingDevice(BaseModel):
    identifier: str = Field(
        ..., description='The device serial number or other globally unique identifier.'
    )
    deviceType: DeviceType = Field(..., description='The type of tracking device.')
    humanTrackingUrl: Optional[AnyUrl] = Field(
        None,
        description='A URL where a human can, for example, see the device location on a map.',
    )
    apiTrackingUrl: Optional[AnyUrl] = Field(
        None,
        description="A URL where a computer can, for example, obtain the device's last known latitude and longitude.",
    )


class Units(Enum):
    mm = 'mm'
    micron = 'micron'


class Units1(Enum):
    mm = 'mm'
    micron = 'micron'
    pixel = 'pixel'


class MimeType(Enum):
    image_png = 'image/png'
    image_jpeg = 'image/jpeg'


class LightType(Enum):
    Visible = 'Visible'
    UV = 'UV'
    other = 'other'


class DropImage1(BaseModel):
    mimeType: MimeType = Field(..., description='The MIME type of the image.')
    light_type: Optional[LightType] = Field(
        None, description='The light used to capture the image.'
    )
    timestamp: Optional[datetime] = Field(
        None,
        description='The date and time when the image was captured. This is to be specified in UTC and conform to ISO 8601.',
        examples=['2024-04-24T14:30:16Z', '20240424T143016Z'],
    )
    url: AnyUrl = Field(
        ...,
        description='A URL where the image can be found. It is assumed that no further authentication is needed to read this image.',
    )
    path: Optional[str] = Field(
        None,
        description='A filesystem path where the image can be found. It is assumed that both sender and receiver have permission to read the image.',
    )
    data: Optional[str] = Field(None, description='The image, UUencoded.')


class DropImage2(BaseModel):
    mimeType: MimeType = Field(..., description='The MIME type of the image.')
    light_type: Optional[LightType] = Field(
        None, description='The light used to capture the image.'
    )
    timestamp: Optional[datetime] = Field(
        None,
        description='The date and time when the image was captured. This is to be specified in UTC and conform to ISO 8601.',
        examples=['2024-04-24T14:30:16Z', '20240424T143016Z'],
    )
    url: Optional[AnyUrl] = Field(
        None,
        description='A URL where the image can be found. It is assumed that no further authentication is needed to read this image.',
    )
    path: str = Field(
        ...,
        description='A filesystem path where the image can be found. It is assumed that both sender and receiver have permission to read the image.',
    )
    data: Optional[str] = Field(None, description='The image, UUencoded.')


class DropImage3(BaseModel):
    mimeType: MimeType = Field(..., description='The MIME type of the image.')
    light_type: Optional[LightType] = Field(
        None, description='The light used to capture the image.'
    )
    timestamp: Optional[datetime] = Field(
        None,
        description='The date and time when the image was captured. This is to be specified in UTC and conform to ISO 8601.',
        examples=['2024-04-24T14:30:16Z', '20240424T143016Z'],
    )
    url: Optional[AnyUrl] = Field(
        None,
        description='A URL where the image can be found. It is assumed that no further authentication is needed to read this image.',
    )
    path: Optional[str] = Field(
        None,
        description='A filesystem path where the image can be found. It is assumed that both sender and receiver have permission to read the image.',
    )
    data: str = Field(..., description='The image, UUencoded.')


class DropImage(RootModel[Union[DropImage1, DropImage2, DropImage3]]):
    root: Union[DropImage1, DropImage2, DropImage3] = Field(
        ..., description='An image of a crystallization drop.', title='Drop image'
    )


class RegionType(Enum):
    point = 'point'


class Point(BaseModel):
    region_type: RegionType
    x: float = Field(..., description='The X co-ordinate of the point.')
    y: float = Field(..., description='The Y co-ordinate of the point.')


class RegionType1(Enum):
    circle = 'circle'


class Circle(BaseModel):
    region_type: RegionType1
    center: Point
    radius: PositiveFloat = Field(..., description='The radius of the circle.')


class RegionType2(Enum):
    line = 'line'


class Line(BaseModel):
    regionType: RegionType2
    points: List[Point] = Field(..., max_length=2, min_length=2)


class RegionType3(Enum):
    rectangle = 'rectangle'


class Rectangle(BaseModel):
    region_type: RegionType3
    points: List[Point] = Field(..., max_length=2, min_length=2)


class RegionType4(Enum):
    polygon = 'polygon'


class Polygon(BaseModel):
    regionType: RegionType4
    points: List[Point] = Field(..., min_length=3)


class PlateType(BaseModel):
    name: Optional[str] = Field(
        None,
        description='The name of the plate type.',
        examples=['Greiner 1-drop square'],
    )
    number_rows: conint(ge=1) = Field(
        ...,
        description='The number of rows in the plate. For a typical 96-well plate, this will be 8.',
    )
    number_columns: conint(ge=1) = Field(
        ...,
        description='The number of columns in the plate. For a typical 96-well plate, this will be 12.',
    )
    number_sub_positions: conint(ge=1) = Field(
        ...,
        description='The number of sub-wells in the plate. For in-situ plates with no dividers, this should be the actual number of drops dispensed.',
    )
    drop_mapping: str = Field(
        ...,
        description="<p>The sender's numbering of the sub-wells. This can be used by the receiver to map the sender's well numbering onto their own.<p><p>It is an error if the sender and receiver disagree on the basic geometry (e.g., three drops across the top with a reservoir underneath). However, they can disagree on the drop order; this property is intended to help overcome such disagreements.</p>",
        examples=['123,RRR', '23,1R'],
    )


class UnattendedCollection(Enum):
    boolean_True = True


class Person(BaseModel):
    name: str = Field(..., description="The person's full name.")
    emailAddress: Optional[str] = Field(None, description="The person's email address.")
    phoneNumber: Optional[str] = Field(None, description="The person's phone number.")


class MxlimsData(BaseModel):
    mxlims_type: str = Field(
        ...,
        description='The type of MXLIMS data. May be restricted to enum in subclasses',
        title='Mxlims Type',
    )
    namespaced_extensions: Optional[List[NamespacedExtension]] = Field(
        None,
        description='List of extensions to metadata, each defined in a NamespacedExtension schema',
        title='Namespaced Extensions',
    )


class CrystalForm1(BaseModel):
    unit_cell: Optional[UnitCell] = Field(
        None, description='Unit cell for Crystal form.'
    )
    space_group_name: SpacegroupName = Field(
        ...,
        description='Name of expected space group, for processing. Names may include alternative settings. Matches mmCIF item symmetry.space_group_name_H-M (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_symmetry.space_group_name_H-M.html).',
        title='Space Group Name',
    )


class CrystalForm2(BaseModel):
    unit_cell: UnitCell = Field(..., description='Unit cell for Crystal form.')
    space_group_name: Optional[SpacegroupName] = Field(
        None,
        description='Name of expected space group, for processing. Names may include alternative settings. Matches mmCIF item symmetry.space_group_name_H-M (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_symmetry.space_group_name_H-M.html).',
        title='Space Group Name',
    )


class CrystalForm(RootModel[Union[CrystalForm1, CrystalForm2]]):
    root: Union[CrystalForm1, CrystalForm2] = Field(
        ...,
        description='Crystal form, fully or partially specified',
        title='Crystal Form',
    )


class QualityFactor(BaseModel):
    type: QualityFactorType = Field(..., description='Quality factor type')
    value: float = Field(..., description='Quality factor value', title='Value')


class MxProcessingData(MxlimsData):
    mxlims_type: Literal['MXProcessing'] = Field(
        'MXProcessing', description='Type of MXLIMS object.', title='Mxlims Type'
    )
    crystal_form: Optional[CrystalForm] = Field(
        None,
        description='Crystal form, with unit cell and space group, to use for processing',
    )


class CollectionSweepData(MxlimsData):
    mxlims_type: Literal['CollectionSweep'] = Field(
        'CollectionSweep', description='The type of MXLIMS object.', title='Mxlims Type'
    )
    annotation: Optional[str] = Field(
        None, description='Annotation string for sweep', title='Annotation'
    )
    sweep_type: Optional[str] = Field(
        'simple',
        description="Type of sweep: 'simple', 'mesh', 'line', 'helical, 'xray_centring'Should be made into an enumeration",
        title='Sweep Type',
    )
    exposure_time: Optional[confloat(ge=0.0)] = Field(
        None, description='Exposure time in seconds', title='Exposure Time'
    )
    image_width: Optional[confloat(ge=0.0)] = Field(
        None,
        description='Width of a single image, along scan_axis. For rotational axes in degrees, for translations in mm.',
        title='Image Width',
    )
    number_images: Optional[conint(ge=0)] = Field(
        None,
        description="Number of images from start to end of sweep.Defines image numbering and final axis position.NB Only certain parts of the sweep may be acquired (see 'scans'),so the total number of images acquired may be less.",
        title='Number Images',
    )
    overlap: Optional[float] = Field(
        None,
        description='Overlap between successivce images, in units of image_width. May be negtive for non-contiguous images.',
        title='Overlap',
    )
    number_triggers: Optional[conint(ge=0)] = Field(
        None,
        description='Number of triggers. Instruction to detector - does not modify effect of other parameters.',
        title='Number Triggers',
    )
    number_images_per_trigger: Optional[conint(ge=0)] = Field(
        None,
        description='Number of images per trigger. Instruction to detector - does not modify effect of other parameters.',
        title='Number Images Per Trigger',
    )
    number_lines: Optional[conint(ge=0)] = Field(
        None,
        description='Number of scanned lines used for mesh scans. Must divide number_images',
        title='Number Lines',
    )
    mesh_range: Optional[List] = Field(
        None,
        description='Mesh scan range (horizontal, vertical) in mm',
        max_length=2,
        min_length=2,
        title='Mesh Range',
    )
    energy: Optional[confloat(ge=0.0)] = Field(
        None, description='Energy of the beam in eV', title='Energy'
    )
    transmission: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None, description='Transmission setting in %', title='Transmission'
    )
    resolution: Optional[float] = Field(
        None,
        description='Resolution that the sweep was intended to measureFor offset or unusual detectors this may *not* determine the detector distanceThe actual detector distance can be found in axis_positions_start',
        title='Resolution',
    )
    detector_roi_mode: Optional[str] = Field(
        None,
        description='Region-of-interest mode of detector. Should be made into an enumeration',
        title='Detector Roi Mode',
    )
    beam_position: Optional[Any] = Field(
        None,
        description='x,y position of the beam on the detector in pixels',
        title='Beam Position',
    )
    beam_size: Optional[List] = Field(
        None,
        description='x,y size of the beam on the detector in mm',
        max_length=2,
        min_length=2,
        title='Beam Size',
    )
    beam_shape: Optional[str] = Field(
        None,
        description='Shape of the beam. NBNB Should be an enumeration',
        examples=['unknown', 'rectangular', 'ellipsoid'],
        title='Beam Shape',
    )
    detector_type: Optional[str] = Field(
        None,
        description='Type of detector, using enumeration of mmCIF items diffrn_detector.type (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_diffrn_detector.type.html)',
        title='Detector Type',
    )
    detector_binning_mode: Optional[str] = Field(
        None,
        description='Binning mode of detector. Should be made into an enumeration',
        title='Detector Binning Mode',
    )
    axis_positions_start: Optional[Dict[str, float]] = Field(
        None,
        description="Dictionary string:float with starting position of all axes, rotations or translations, including detector distance, by name. Units are mm for distances, degrees for anglesNBNB do we use internal motor names (e.g. 'phi'), or std. names (e.g. 'omega')?",
        title='Axis Positions Start',
    )
    axis_positions_end: Optional[Dict[str, float]] = Field(
        None,
        description='Dictionary string:float with final position of scanned axes as for axis_positions_start.scanned_axis position is NOT given here, but is calculatedfrom image_width, overlap, number_images, and axis_position_startNB scans may be acquired out of order, so this determines the limits of the sweep, not the temporal start and end points',
        title='Axis Positions End',
    )
    scan_axis: str = Field(
        ...,
        description='Name of main scanned axis. Other axes may be scanned in parallel.For mesh scans name of fastest scanned axis',
        examples=[
            'omega',
            'kappa',
            'phi',
            'chi',
            'twoTheta',
            'sampleX',
            'sampleY',
            'sampleZ',
            'detectorX',
            'detectorY',
            'horizontal',
            'vertical',
        ],
        title='Scan Axis',
    )
    scans: Optional[List[Scan]] = Field(
        None,
        description='List of Scans i.e. subdivisions of CollectionSweepNB Scans need not be contiguous or in order or add up to entire sweep',
        title='Scans',
    )
    file_type: Optional[str] = Field(
        None,
        description='Type of file.',
        examples=['mini-cbf', 'imgCIF', 'FullCBF', 'HDF5', 'MarCCD'],
        title='File Type',
    )
    prefix: Optional[str] = Field(
        None,
        description='Input parameter - used to build the fine name template.',
        title='Prefix',
    )
    filename_template: Optional[str] = Field(
        None,
        description='File name template,  includes prefix, suffix, run number, and a slot where image number can be filled in.',
        title='Filename Template',
    )
    path: Optional[str] = Field(
        None, description='Path to directory containing image files.', title='Path'
    )


class MxExperimentData(MxlimsData):
    mxlims_type: Literal['MXExperiment'] = Field(
        'MXExperiment', description='The type of MXLIMS object.', title='Mxlims Type'
    )
    experiment_strategy: Optional[str] = Field(
        None,
        description='Experiment strategy indicator',
        examples=[
            'OSC',
            'Helical',
            'MXPressE',
            'GPhL.native.basic',
            'GPhL.SAD.advanced',
            'GPhL.2wvlMAD.basic',
        ],
        title='Experiment Strategy',
    )
    expected_resolution: Optional[confloat(ge=0.0)] = Field(
        None,
        description='The resolution expected in the experiment - for positioning the detector and setting up the experiment',
        title='Expected Resolution',
    )
    target_completeness: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description='Minimal completeness expected from experiment',
        title='Target Completeness',
    )
    target_multiplicity: Optional[confloat(ge=0.0)] = Field(
        None,
        description='Minimal multiplicity expected from experiment',
        title='Target Multiplicity',
    )
    dose_budget: Optional[confloat(ge=0.0)] = Field(
        None, description='Dose (MGy) to be used in experiment', title='Dose Budget'
    )
    snapshot_count: Optional[conint(ge=0)] = Field(
        0,
        description='Number of snapshots to acquire after each (re)centring',
        title='Snapshot Count',
    )
    wedge_width: Optional[confloat(ge=0.0)] = Field(
        None,
        description='Wedge width (in degrees) to use for interleaving',
        title='Wedge Width',
    )
    measured_flux: Optional[confloat(ge=0.0)] = Field(
        None,
        description='Measured value of beam flux in photons/s',
        title='Measured Flux',
    )
    radiation_dose: Optional[confloat(ge=0.0)] = Field(
        None,
        description='Total radiation dose absorbed during experiment',
        title='Radiation Dose',
    )
    crystal_form: Optional[CrystalForm] = Field(
        None,
        description='Crystal form, with unit cell and space group, as determined during characterisation',
    )


class CrystallographicSampleData(MxlimsData):
    macromolecule: Optional[SampleComponent] = Field(
        None, description='Macromolecule being studied - main component of the sample'
    )
    components: Optional[List[SampleComponent]] = Field(
        None, description='Other components of Sample', title='Sample components'
    )
    crystal_form: Optional[CrystalForm] = Field(
        None,
        description='Crystal form, with unit cell and space group, as determined during processing',
    )
    identifiers: Optional[Dict[str, str]] = Field(
        None,
        description="Dictionary str:str of contextName: identifier. ContextName will typically refer to a LIMS, database, or web site but could also be e.g. 'smiles' or 'sequence'",
        title='Identifiers',
    )


class CrystalData(MxlimsData):
    comment: Optional[str] = Field(None, description='Comment or annotation.')


class PinPositionData(MxlimsData):
    position_in_pin: conint(ge=1) = Field(
        ...,
        description="The pin position within  the pin. This should be validated against the pin's number_positions property.",
        examples=[4],
    )


class PinData(MxlimsData):
    barcode: Optional[str] = Field(None, description='The Pin barcode or RFID code')
    number_positions: conint(ge=1) = Field(
        ..., description='The number of positions available in the Pin.'
    )
    position_in_puck: conint(ge=1) = Field(
        ...,
        description="The puck position occupied by the pin. This should be validated against the puck's number_positions property.",
        examples=[16],
    )


class PuckData(MxlimsData):
    barcode: Optional[str] = Field(None, description='The Puck barcode or RFID code')
    number_positions: conint(ge=1) = Field(
        ..., description='The number of pin positions available.'
    )


class DewarData(MxlimsData):
    barcode: Optional[str] = Field(None, description='The dewar barcode or RFID code')
    tracking_device: Optional[TrackingDevice] = None


class Region(RootModel[Union[Point, Circle, Line, Rectangle, Polygon]]):
    root: Union[Point, Circle, Line, Rectangle, Polygon] = Field(
        ..., description='A region or point of interest.', title='Region'
    )


class WellDropData(MxlimsData):
    drop_number: conint(ge=1) = Field(
        ...,
        description="The drop number. This should be validated against the plateType's number_sub_positions property.",
    )


class PlateWellData(MxlimsData):
    row_number: Optional[conint(ge=1)] = Field(
        None,
        description="<The row number of this well. This is 1-based, so row A is 1, row H is 8. This should be validated against the plateType's rows property.",
    )
    column_number: Optional[conint(ge=1)] = Field(
        None,
        description="<The column number of this well. This is 1-based, so should match the column labels on the plate. This should be validated against the plateType's columns property.",
    )
    name: Optional[str] = Field(
        None,
        description='A human-friendly well identifier. If present, this should be validated to ensure that it refers to the correct row and column.',
        examples=['H1', 'C03'],
    )


class PlateData(MxlimsData):
    barcode: Optional[str] = Field(
        None, description='The plate barcode or otehr identifier'
    )
    plate_type: Optional[PlateType] = None
    identifiers: Optional[Dict[str, str]] = Field(
        None,
        description="Dictionary str:str of contextName: identifier. ContextName will typically refer to a LIMS, database, or web site but could also be e.g. 'smiles' or 'sequence'",
        title='Identifiers',
    )
    tracking_device: Optional[TrackingDevice] = None


class ShipmentData(MxlimsData):
    proposal_code: str = Field(
        ...,
        description='The proposal number at the receiving facility.',
        examples=['mx1234'],
    )
    session_number: Optional[conint(ge=1)] = Field(
        None,
        description='The session number within the proposal. This property must be absent if <code>unattendedCollection</code> is present.',
    )
    comments: Optional[constr(max_length=250)] = Field(
        None, description='A comment about the shipment.'
    )
    unattended_collection: Optional[UnattendedCollection] = Field(
        None,
        description='If this shipment is for unattended collection, then this property must be present and true. Otherwise, it must be absent and a <code>session</code> must be present.',
    )
    labContactOutbound: Optional[Person] = None
    labContactReturn: Optional[Person] = None
    identifiers: Optional[Dict[str, str]] = Field(
        None,
        description="Dictionary str:str of contextName: identifier. ContextName will typically refer to a LIMS, database, or web site but could also be e.g. 'smiles' or 'sequence'",
        title='Identifiers',
    )
    trackingDevice: Optional[TrackingDevice] = None


class MxlimsObject(BaseModel):
    version: Literal['0.3.0'] = Field(
        ..., description='MXLIMS version for current model', title='Version'
    )
    uuid: UUID = Field(
        ..., description='Permanent unique identifier string', title='Uuid'
    )
    data: MxlimsData = Field(
        ..., description='Metadata object, also defining the precise type.'
    )
    extensions: Optional[Dict[str, Any]] = Field(
        None,
        description='Keyword-value dictionary string:Any of extensions. Use is accepted but discouraged',
        title='Extensions',
    )


class Dataset(MxlimsObject):
    source_id: Optional[UUID] = Field(
        None,
        description='String UUID of Job that created this Dataset.',
        title='Source Id',
    )
    role: Optional[str] = Field(
        None,
        description='Role of Dataset realtive to the source Job. Intended for filtering of Datasets',
        examples=['Result', 'Intermediate', 'Characterisation', 'Centring'],
        title='Role',
    )
    logistical_sample_id: Optional[UUID] = Field(
        None,
        description='String UUID of LogisticalSample relevant to Dataset.',
        title='Logistical Sample Id',
    )
    derived_from_id: Optional[UUID] = Field(
        None,
        description="String UUID of Dataset from which this Dataset was derived. Used for modified Datasets without a 'source' link, e.g. when removing images from a sweep before processing.",
        title='Derived From Id',
    )


class ReflectionStatistics(BaseModel):
    resolution_limits: List = Field(
        ...,
        description='lower, higher resolution limit of shell, matches mmCIF items reflns_shell.d_res_low (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.d_res_low.html) and reflns_shell.d_res_high (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.d_res_high.html)',
        max_length=2,
        min_length=2,
        title='Resolution Limits',
    )
    number_observations: Optional[conint(ge=0)] = Field(
        None,
        description='total number of observations, matches mmCIF item reflns_shell.number_measured_all (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.number_measured_all.html)',
        title='Number Observations',
    )
    number_observations_unique: Optional[conint(ge=0)] = Field(
        None,
        description='total number of unique observations, matches mmCIF item reflns_shell.number_unique_all (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.number_unique_all.html)',
        title='Number Observations Unique',
    )
    number_reflections_rejected: Optional[conint(ge=0)] = Field(
        None,
        description='Number of rejected reflections within this resolution shell, matches mmCIF item reflns_shell.pdbx_rejects.html (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_rejects.html)',
        title='Number Reflections Rejected',
    )
    chi_squared: Optional[confloat(ge=0.0)] = Field(
        None,
        description='Chi-squared statistic for reflection shell, matches mmCIF item reflns_shell.pdbx_chi_squared (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns_shell.pdbx_chi_squared.html)',
        title='Chi Squared',
    )
    quality_factors: Optional[List[QualityFactor]] = Field(
        None,
        description='Quality factors for reflection shell, ',
        title='Quality Factors',
    )


class CollectionSweep(Dataset):
    data: Optional[CollectionSweepData] = None


class PreparedSample(MxlimsObject):
    pass


class PlateRegion(BaseModel):
    region: Region
    units: Units = Field(..., description="The units of the region's co-ordinates.")


class ImageRegion(BaseModel):
    region: Region
    image: Optional[DropImage] = None
    units: Units1 = Field(..., description="The units of the region's co-ordinates.")


class Job(MxlimsObject):
    sample_id: Optional[str] = Field(
        None,
        description='String UUID of the PreparedSample that applies to this Job',
        title='Sample Id',
    )
    logistical_sample_id: Optional[UUID] = Field(
        None,
        description='String UUID of LogisticalSample relevant to this Job.',
        title='Logistical Sample Id',
    )
    started_from_id: Optional[UUID] = Field(
        None,
        description='String UUID of the Job from which this Job was started.',
        title='Started From Id',
    )
    start_time: Optional[datetime] = Field(
        None,
        description='Actual starting time for job or calculation, ',
        title='Start Time',
    )
    end_time: Optional[datetime] = Field(
        None,
        description='Actual finishing time for job or calculation, ',
        title='End Time',
    )
    job_status: Optional[JobStatus] = Field(
        None,
        description='Status of job - enumerated, ',
        examples=['Template', 'Ready', 'Running', 'Completed', 'Failed', 'Aborted'],
    )
    input_data_ids: Optional[List[UUID]] = Field(
        None,
        description='String UUID of input Datasets for this Job.',
        title='Input Data Ids',
    )
    reference_data_ids: Optional[List[UUID]] = Field(
        None,
        description='String UUID of reference Datasets for this Job.',
        title='Reference Data Ids',
    )
    template_data_ids: Optional[List[UUID]] = Field(
        None,
        description='String UUID of template Datasets for this Job.',
        title='Template Data Ids',
    )
    subjobs: Optional[List[Job]] = Field(
        None,
        description='List of Jobs started from this job. NB the started_from_id of the jobs must point to this Job.This field allows attached jobs to be contained directly in the JSON fileand allows for constraining job types in subtypes',
        title='Subjobs',
    )
    results: Optional[List[Dataset]] = Field(
        None,
        description='List of Datasets created from this job. NB the source_id of the datasets must point to this Job.This field allows result Datasets to be contained directly in the JSON fileand allows for constraining Dataset types in subtypes',
        title='Results',
    )
    template_data: Optional[List[Dataset]] = Field(
        None,
        description='List of Template Datasets used for this job. NB the id of the datasets must match the IDs in template_data_ids.This field allows template Datasets to be contained directly in the JSON fileand allows for constraining Dataset types in subtypes.NB Note that two different specifications of a dataset cannot have the same ID',
        title='Template Data',
    )


class ReflectionSetData(MxlimsData):
    mxlims_type: Literal['ReflectionSet'] = Field(
        'ReflectionSet',
        description='Type of MXLIMS object linked to.',
        title='Mxlims Type',
    )
    anisotropic_diffraction: Optional[bool] = Field(
        False,
        description='Is diffraction limit analysis based on anisotropic diffraction limits? True/False ',
        title='Anisotropic Diffraction',
    )
    crystal_form: Optional[CrystalForm] = Field(
        None,
        description='Crystal form, with unit cell and space group, as determined during processing',
    )
    operational_resolution: Optional[float] = Field(
        None,
        description='Operational resolution (A) matching observed_criteria.',
        title='Operational Resolution',
    )
    diffraction_limits_estimated: Optional[Tensor] = Field(
        None,
        description='Principal axes lengths (A) of ellipsoid describing reciprocal space region containing observable reflections, regardless whether all have actually been observed. Matches mmCIF items reflns.pdbx_aniso_diffraction_limit_{1,2,3} (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_aniso_diffraction_limit_1.html)',
    )
    wavelengths: Optional[List[confloat(ge=0.0)]] = Field(
        None,
        description='Wavelengths (A) at which reflections were measured',
        title='Wavelengths',
    )
    B_iso_Wilson_estimate: Optional[float] = Field(
        None,
        description='estimated (isotropic) temperature factor from slope of Wilson plot, matches mmCIF item reflns.B_iso_Wilson_estimate (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.B_iso_Wilson_estimate.html)',
        title='B Iso Wilson Estimate',
    )
    aniso_B_tensor: Optional[Tensor] = Field(
        None,
        description='Anisotropic B tensor, matching mmCIF items reflns.pdbx_aniso_B_tensor_eigenvalue_{1,2,3} and reflns.pdbx_aniso_B_tensor_eigenvector_{1,2,3}_ortho[{1,2,3}] (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_aniso_B_tensor_eigenvalue_1.html)',
    )
    number_reflections: Optional[conint(ge=0)] = Field(
        None,
        description='Total number of measured reflections, matches mmCIF item reflns.pdbx_number_measured_all (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_number_measured_all.html)',
        title='Number of Reflections',
    )
    number_reflections_unique: Optional[conint(ge=0)] = Field(
        None,
        description='Total number of unique reflections, matches mmCIF item reflns.number_obs (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.number_obs.html)',
        title='Number Reflections Unique',
    )
    h_index_range: Optional[List] = Field(
        None,
        description='low and high limit on Miller index h, matches mmCIF item reflns.limit_h_min (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_h_min.html) and reflns.limit_h_max (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_h_max.html)',
        max_length=2,
        min_length=2,
        title='H Index Range',
    )
    k_index_range: Optional[List] = Field(
        None,
        description='low and high limit on Miller index k, matches mmCIF item reflns.limit_k_min (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_k_min.html) and reflns.limit_k_max (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_k_max.html)',
        max_length=2,
        min_length=2,
        title='K Index Range',
    )
    l_index_range: Optional[List] = Field(
        None,
        description='low and high limit on Miller index l, matches mmCIF item reflns.limit_l_min (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_l_min.html) and reflns.limit_l_max (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.limit_l_max.html)',
        max_length=2,
        min_length=2,
        title='L Index Range',
    )
    reflection_statistics_overall: Optional[ReflectionStatistics] = Field(
        None, description='Reflection statistics for all processed reflections'
    )
    reflection_statistics_shells: Optional[List[ReflectionStatistics]] = Field(
        None,
        description='Reflection statistics per resolution shell',
        title='Reflection Statistics Shells',
    )
    signal_type: Optional[PdbxSignalType] = Field(
        None,
        description="'local <I/sigmaI>', 'local wCC_half'; matches reflns.pdbx_signal_type (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_signal_type.html). Criterion for observability, as used in mmCIF refln.pdbx_signal_status (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_refln.pdbx_signal_status.html)",
    )
    signal_cutoff: Optional[float] = Field(
        None,
        description='Limiting value for signal calculation; matches reflns.pdbx_observed_signal_threshold (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_reflns.pdbx_observed_signal_threshold.html). Cutoff for observability, as used in mmCIF refln.pdbx_signal_status (https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_refln.pdbx_signal_status.html)',
        title='Signal Cutoff',
    )
    resolution_cutoffs: Optional[List[QualityFactor]] = Field(
        None,
        description='Criteria used in determination of isotropic resolution cut-off (e.g. as implemented in MRFANA, https://github.com/githubgphl/MRFANA)',
        title='Resolution Cutoffs',
    )
    binning_mode: Optional[ReflectionBinningMode] = Field(
        None, description='Binning mode for definition of resolution shells'
    )
    number_bins: Optional[PositiveInt] = Field(
        None, description='Number of bins', title='Number Bins'
    )
    reflections_per_bin: Optional[PositiveInt] = Field(
        None, description='Number of reflections per bin', title='Reflections Per Bin'
    )
    reflections_per_bin_per_sweep: Optional[PositiveInt] = Field(
        None,
        description='Number of reflections per bin per sweep (in multi-sweep experiment)',
        title='Reflections Per Bin Per Sweep',
    )
    resolution_rings_detected: Optional[List[List]] = Field(
        None,
        description='Resolution rings detected as originating from ice, powder diffraction etc.; given as a pair of floats (A) with decreasing value, i.e. low- and high-resolution limits',
        title='Resolution Rings Detected',
    )
    resolution_rings_excluded: Optional[List[List]] = Field(
        None,
        description='Resolution rings excluded from calculation; given as a pair of floats (A) with decreasing value, i.e. low- and high-resolution limits)',
        title='Resolution Rings Excluded',
    )
    file_type: Optional[ReflectionFileType] = Field(None, description='Type of file')
    filename: Optional[str] = Field(None, description='File name.', title='Filename')
    path: Optional[str] = Field(
        None,
        description='Path to directory containing reflection set file (defined by filename).',
        title='Path',
    )


class MxExperiment(Job):
    data: Optional[MxExperimentData] = None
    contents: Optional[List[CollectionSweep]] = Field(None, min_length=1)


class CrystallographicSample(PreparedSample):
    data: Optional[CrystallographicSampleData] = None


class LogisticalSample(MxlimsObject):
    sample_id: Optional[UUID] = Field(
        None,
        description='String UUID of the PreparedSemple that applies to this LogisticalSample and all its contents',
        title='Sample Id',
    )
    container_id: Optional[UUID] = Field(
        None,
        description='String UUID of the LogisticalSample containing this one',
        title='Container Id',
    )
    contents: Optional[List[LogisticalSample]] = Field(
        None,
        description='List of directly contained LogisticalSamples.NB the container_id of the contents must point to this LogisticalSample.This field allows contents to be contained directly in the JSON fileand allows for constraining content types in subtypes(E.g. Pucks can only contain contain Pins',
        title='Contents',
    )
    jobs: Optional[List[Job]] = Field(
        None,
        description='List of directly attached Jobs.NB the logistical_sample_id of the jobs must point to this LogisticalSample.This field allows attached jobs to be contained directly in the JSON fileand allows for constraining job types in subtypes',
        title='Jobs',
    )


class Crystal(LogisticalSample):
    data: Optional[CrystalData] = None
    contents: Optional[List[Crystal]] = None


class DropRegionData(MxlimsData):
    image_region: Optional[ImageRegion] = None
    plate_region: Optional[PlateRegion] = None


class ReflectionSet(Dataset):
    data: Optional[ReflectionSetData] = None


class PinPosition(LogisticalSample):
    data: Optional[PinPositionData] = None
    contents: Optional[List[Crystal]] = Field(None, min_length=1)


class DropRegion(LogisticalSample):
    data: Optional[DropRegionData] = None
    contents: Optional[List[Crystal]] = Field(None, min_length=1)


class MxProcessing(Job):
    data: Optional[MxProcessingData] = None
    contents: Optional[List[ReflectionSet]] = Field(None, min_length=1)


class Pin(LogisticalSample):
    data: Optional[PinData] = None
    contents: Optional[List[PinPosition]] = Field(None, min_length=1)


class WellDrop(LogisticalSample):
    data: Optional[WellDropData] = None
    contents: Optional[List[DropRegion]] = Field(None, min_length=1)


class Puck(LogisticalSample):
    data: Optional[PuckData] = None
    contents: Optional[List[Pin]] = Field(None, min_length=1)


class PlateWell(LogisticalSample):
    data: Optional[PlateWellData] = None
    contents: Optional[List[WellDrop]] = Field(None, min_length=1)


class Dewar(LogisticalSample):
    data: Optional[DewarData] = None
    contents: Optional[List[Puck]] = Field(None, min_length=1)


class Plate(LogisticalSample):
    data: Optional[PlateData] = None
    contents: Optional[List[PlateWell]] = Field(None, min_length=1)


class Shipment(LogisticalSample):
    data: Optional[ShipmentData] = None
    contents: Optional[Union[List[Dewar], List[Plate]]] = None


class MxlimsMessage(BaseModel):
    jobs: Optional[List[Union[MxProcessing, MxExperiment]]] = Field(
        None, description='List of directly contained Jobs.', title='Jobs'
    )
    datasets: Optional[List[Union[CollectionSweep, ReflectionSet]]] = Field(
        None, description='List of directly contained Datasets.', title='Datasets'
    )
    prepared_samples: Optional[List[CrystallographicSample]] = Field(
        None,
        description='List of directly contained Prepared Samples.',
        title='Prepared Samples',
    )
    logistical_samples: Optional[List[Shipment]] = Field(
        None,
        description='List of directly contained Logistical Samples.',
        title='Logistical Samples',
    )


Job.model_rebuild()
LogisticalSample.model_rebuild()
Crystal.model_rebuild()
